
[

{
"name": "API Design First",
"version": "2021-11-24",
"description": "",
"conclusion": "Text",
"image": "workflow.png",
"tags": ["Design","Design First"],
"stage": "Automation",
"type": "sync",
"order": 1,
"status": "draft",
"maturity": "optimized",
"version": "2021-11-24",
"areas": [{"label":"Design","description":"Text","image":"images/lifecycle-arrow-define.png","elements":[{"name":"OpenAPI","label":"OpenAPI"},{"name":"Mock Server","label":"Mock Server"},{"name":"Documentation","label":"Documentation"},{"name":"Contract Testing","label":"Contract Testing"}]},{"label":"Collaboration","description":"Text","image":"images/lifecycle-arrow-define.png","elements":[{"name":"Comments","label":"Comments"},{"name":"Inline Comments","label":"Inline Comments"},{"name":"Notifications","label":"Notifications"},{"name":"Sharing","label":"Sharing"}]}],
"discussion": "",
"yaml": "",
"roles": ["Backend","Data","DevOps","Engineering","Frontend","Mobile","Product","Security","Writers"],
"content": ""
}
,

{
"name": "API-First",
"version": "2021-11-24",
"description": "",
"conclusion": "Text",
"image": "workflow.png",
"tags": ["Requests"],
"stage": "Automation",
"type": "sync",
"order": 1,
"status": "draft",
"maturity": "optimized",
"version": "2021-11-24",
"areas": [{"label":"Applications","description":"Text","image":"images/lifecycle-arrow-define.png","elements":[{"name":"Web Applications","label":"Web Applications"},{"name":"Mobile Applications","label":"Mobile Applications"},{"name":"Device Applications","label":"Device Applications"},{"name":"Integrations","label":"Integrations"}]},{"label":"Definitions","description":"Text","image":"images/lifecycle-arrow-define.png","elements":[{"name":"OpenAPI","label":"OpenAPI"},{"name":"AsyncAPI","label":"AsyncAPI"},{"name":"JSON Schema","label":"JSON Schema"},{"name":"Postman Collections","label":"Postman Collections"}]},{"label":"Discovery","description":"Text","image":"images/lifecycle-arrow-define.png","elements":[{"name":"Teams","label":"Teams"},{"name":"Workspaces","label":"Workspaces"},{"name":"Artifacts","label":"Artifacts"},{"name":"Search","label":"Search"},{"name":"Internal Network","label":"Internal Network"},{"name":"Partner Network","label":"Partner Network"},{"name":"Public Network","label":"Public Network"}]},{"label":"Visibility","description":"Text","image":"images/lifecycle-arrow-define.png","elements":[{"name":"Private APIs","label":"Private APIs"},{"name":"Team APIs","label":"Team APIs"},{"name":"Partner APIs","label":"Partner APIs"},{"name":"Public APIs","label":"Public APIs"}]},{"label":"Observability","description":"Text","image":"images/lifecycle-arrow-define.png","elements":[{"name":"Monitoring","label":"Monitoring"},{"name":"History","label":"History"},{"name":"Activity","label":"Activity"},{"name":"Reporting","label":"Reporting"},{"name":"APM","label":"APM"}]},{"label":"Standards","description":"Text","image":"images/lifecycle-arrow-define.png","elements":[{"name":"Internet Standards","label":"Internet Standards"},{"name":"Industry Standards","label":"Industry Standards"},{"name":"Organizational Standards","label":"Organizational Standards"}]},{"label":"Governance","description":"Text","image":"images/lifecycle-arrow-define.png","elements":[{"name":"Design Governance","label":"Design Governance"},{"name":"Documentation Governance","label":"Documentation Governance"},{"name":"Testing Governance","label":"Testing Governance"}]}],
"discussion": "",
"yaml": "",
"roles": ["Advocate","Architect","CIO","CISO","CTO","Engineering","Product"],
"content": ""
}
,

{
"name": "Applications",
"version": "2021-11-24",
"description": "",
"conclusion": "Text",
"image": "workflow.png",
"tags": ["Requests"],
"stage": "Automation",
"type": "sync",
"order": 1,
"status": "draft",
"maturity": "optimized",
"version": "2021-11-24",
"areas": [{"label":"Types","description":"Text","image":"images/lifecycle-arrow-define.png","elements":[{"name":"Web","label":"Web"},{"name":"Mobile","label":"Mobile"},{"name":"Device","label":"Device"},{"name":"Integrations","label":"Integrations"},{"name":"Workflows","label":"Workflows"},{"name":"Network","label":"Network"}]},{"label":"Lifecycle","description":"Text","image":"images/lifecycle-arrow-define.png","elements":[{"name":"Discover","label":"Discover"},{"name":"Define","label":"Define"},{"name":"Design","label":"Design"},{"name":"Develop","label":"Develop"},{"name":"Deploy","label":"Deploy"},{"name":"Observe","label":"Observe"}]},{"label":"Observablity","description":"Text","image":"images/lifecycle-arrow-define.png","elements":[{"name":"Testing","label":"Testing"},{"name":"Security","label":"Security"},{"name":"Monitoring","label":"Monitoring"},{"name":"Pipeline","label":"Pipeline"},{"name":"APM","label":"APM"},{"name":"Reporting","label":"Reporting"}]}],
"discussion": "",
"yaml": "",
"roles": ["Advocate"],
"content": ""
}
,

{
"name": "Build a Business Workflow",
"version": "2021-09-11",
"description": "",
"conclusion": "This blueprint looks at how you can approach the development and operation of API-driven workflows using a well defined API lifecycle. Each element within this blueprint works to provide a simple overview of what is involved across the entire life of an API, with more detail present on the detail page for each element (if you are viewing this on the API lifecycle project site). If you are reading this via a PDF or printed version you can visit the landing page for this blueprint to access more information and view specific actions you might possibly consider taking as part of applying each element of this proposed lifecycle within your own operations. This blueprint is a living document and will continue to evolve and be added to over time based upon feedback from readers. If you have any questions, feedback, or feel like there is more information you need, feel free to jump on the Github discussion for this blueprint, or any of the individual elements present--the value this blueprint provides is actively defined by the feedback community members like you.",
"image": "workflow.png",
"tags": ["OpenAPI","Design-First"],
"stage": "Automation",
"type": "sync",
"order": 1,
"status": "",
"maturity": "stable",
"version": "2021-09-11",
"areas": [{"label":"Define","description":"Ensuring that operations supporting an API is properly defined, as well as what is needed to properly design and bring an API to life. A little planning and organization at this step of an APIs journey can go a long way towards ensuring the overall health and velocity of an API, and the applications that depend on this internal, partner, or public API.","image":"images/lifecycle-arrow-define.png","elements":[{"name":"Team Workspace","label":"Team Workspace"}]},{"label":"Design","image":"images/lifecycle-arrow-design.png","description":"Having a formal process and approach to designing an API helps establish consistency and the precision of APIs in production, ensuring that APIs are developed using common patterns across an industry, and within an organization, establishing known practices for shaping the surface area and behaviors of APIs that applications are depending upon.","elements":[{"name":"Workflow Collection","label":"Workflow Collection"}]},{"label":"Document","image":"images/lifecycle-arrow-document.png","description":"Having complete, accurate, and easy to follow document is essential for all APIs, helping alleviate the number one pain point for API consumers when it comes to onboarding with an API, as well as expanding the number of API paths an application puts to work, making API documentation one of the most important areas of the API lifecycle.","elements":[{"name":"Workflow Documentation","label":"Workflow Documentation"}]},{"label":"Test","image":"images/lifecycle-arrow-test.png","description":"A test-driven API lifecycle ensures that each API accomplishes the intended purpose it was developed for, providing manual and automated ways to ensure an API hasn't changed unexpectedly, is as performant as required, and meets the security expectations of everyone involved, helping establish a high quality of service consistently across all APIs.","elements":[{"name":"Workflow Testing","label":"Workflow Testing"}]},{"label":"Monitor","image":"images/lifecycle-arrow-monitor.png","description":"All tests applied to an API should be monitored on a logical schedule and from relevant geographic regions, monitoring that APIs aren't breaking their contract, falling below their agreed upon service level agreement (SLA), or becoming a security risk, helping automate the quality of service across APIs in a way that allows teams to be as productive as possible.","elements":[{"name":"Workflow Testing Monitor","label":"Workflow Testing Monitor"},{"name":"Workflow Testing Monitor Results","label":"Workflow Testing Monitor Results"}]}],
"discussion": "https://github.com/postman-open-technologies/lifecycle/discussions/29",
"yaml": "https://github.com/postman-open-technologies/lifecycle/blob/main/_blueprints/business-workflows.md",
"roles": ["Advocate","Architect","Backend","CIO","CISO","CTO","Data","DevOps","Engineering","Frontend","Mobile","Product","Sales","Security","Support","Writers"],
"content": "&lt;p&gt;A standardized API lifecycle can be applied to the design, development, and usage of API business workflows that are defined as machine readable collections which can be automated using monitors and CI/CD pipelines. Postman collections provide a versatile approach to defining multiple individual API requests that include authentication, parameters, headers, and other details, then organize into folders and specific sequences. Providing a format for defining, documenting, but then also executing common business workflows across many internal, partner, or external APIs. Something becomes endlessly useful when managed as part of a well defined lifecycle, equipping developers with what they need to define and design the workflows, but also maintain them, execute them, and use them to automate a variety of business tasks that exist in their worlds.&lt;/p&gt;"
}
,

{
"name": "Capability Collection",
"version": "2021-11-24",
"description": "",
"conclusion": "Text",
"image": "workflow.png",
"tags": ["Requests"],
"stage": "Automation",
"type": "sync",
"order": 1,
"status": "draft",
"maturity": "optimized",
"version": "2021-11-24",
"areas": [{"label":"Purpose","description":"Text","image":"images/lifecycle-arrow-define.png","elements":[{"name":"Single Purpose","label":"Single Purpose"},{"name":"Cognitive Load","label":"Cognitive Load"},{"name":"Automation","label":"Automation"},{"name":"Orchestration","label":"Orchestration"},{"name":"Engagement","label":"Engagement"}]},{"label":"Structure","description":"Text","image":"images/lifecycle-arrow-define.png","elements":[{"name":"Authorization","label":"Authorization"},{"name":"Folders","label":"Folders"},{"name":"Requests","label":"Requests"},{"name":"Scripts","label":"Scripts"},{"name":"Examples","label":"Examples"}]},{"label":"Environment","description":"Text","image":"images/lifecycle-arrow-define.png","elements":[{"name":"Stages","label":"Stages"},{"name":"Variables","label":"Variables"},{"name":"Authorization Variables","label":"Authorization Variables"}]},{"label":"Engagement","description":"Text","image":"images/lifecycle-arrow-define.png","elements":[{"name":"Collection URL","label":"Collection URL"},{"name":"Collection Button","label":"Collection Button"},{"name":"Collection Watch","label":"Collection Watch"},{"name":"Collection Fork","label":"Collection Fork"},{"name":"Collection Pull Request","label":"Collection Pull Request"},{"name":"Collection Merge","label":"Collection Merge"}]}],
"discussion": "",
"yaml": "",
"roles": ["Advocate","Architect","CIO","CISO","CTO","Engineering","Product"],
"content": ""
}
,

{
"name": "Creating a New GraphQL API",
"version": "2021-09-11",
"description": "",
"conclusion": "",
"image": "graphql.png",
"tags": ["GrappQL","SOAP","Web Service"],
"stage": "New",
"type": "sync",
"order": 7,
"status": "",
"maturity": "draft",
"version": "2021-09-11",
"areas": [{"label":"Define","image":"images/lifecycle-arrow-define.png","description":"GraphQL provides a rich set of solutions for defining the base of an API that will expose the entire surface area of one or many data sources, providing API producers with the ability to define data sources and the resolvers that route API requests to each data source, and the schema that will define how API consumers can craft queries for getting at exactly the data they need. Each of these elements help define the base for a GraphQL API, bypassing the work that is required to design a more RESTful approach to delivering APIs, putting more control into the hands of API consumers. Providing a solid approach to defining access to essential and complex backend data using an increasingly common API pattern.","elements":[{"name":"Schema","label":"Schema"},{"name":"Data Sources","label":"Data Sources"},{"name":"Resolvers","label":"Resolvers"}]},{"label":"Document","image":"images/lifecycle-arrow-document.png","description":"Having complete, accurate, and easy to follow documentation is essential for all APIs, and is something that  alleviates the number one pain point for API consumers when it comes to onboarding with any API, expanding the number of API paths an application puts to work. Modern approaches to producing API documentation have moved beyond a single static version of documentation simply published to a portal, as well as there being potentially multiple forms of documentation for any single API. Helping API producers onboard consumers easier, reduce the cognitive load when understanding what an API does, and properly define specific business use cases of an API being put to work in an application or as part of an integration.","elements":[{"name":"Reference Documentation","label":"Reference Documentation","context":1}]},{"label":"Test","image":"images/lifecycle-arrow-test.png","description":"A test-driven API lifecycle ensures that each API delivers the intended outcomes it was developed for in the first place, providing manual as well as automated ways to ensure an API hasn't changed unexpectedly and is as performant as required, helping establish a high quality of service consistently across all APIs. API testing should not be an afterthought and should be a default aspect of the API lifecycle for any API being put into production. API testing takes a solid investment in establishing proper testing practices across teams, but once you do the work to establish a baseline of testing, properly train teams on the process and tooling involved, the investment will pay off down the road.","elements":[{"name":"Contract Testing","label":"Contract Testing","context":1},{"name":"Performance Testing","label":"Performance Testing","context":1}]},{"label":"Secure","image":"images/lifecycle-arrow-test.png","description":"Security must be its own area of the API lifecycle, but it is something that should span testing, authentication, and potentially other areas of the API lifecycle. Over the last five years the world of API security has expanded, while also moving further left in the API lifecycle as part of a devops shift in how APIs are delivered. There are a number of elements present when it comes to security, but depending on the overall maturity of API operations the available resources and prioritization available to adequately realize these elements vary.","elements":[{"name":"Authentication","label":"Authentication","context":1},{"name":"Security Testing","label":"Security Testing","context":1}]},{"label":"Monitor","image":"images/lifecycle-arrow-monitor.png","description":"Monitors can be used to execute any Postman collection applied to any environment. Due to the versatility of what a Postman collection can define, collections turn monitors into a powerful API automation and orchestration tool. Beginning with the ability to schedule contract, performance, and other types of tests, but then also allowing for automating specific workflows across many different APIs. Since collections can be used to define anything that can be defined via an API, monitors can be used to schedule the running of each capability from multiple cloud regions, applying many different environmental variables. Making monitors an essential, versatile, and executable part of defining how the API lifecycle works.","elements":[{"name":"Contract Testing Monitor","label":"Contract Testing Monitor","context":1},{"name":"Performance Testing Monitor","label":"Performance Testing Monitor","context":1}]},{"label":"Discover","image":"images/lifecycle-arrow-discover.png","description":"The ability to discover APIs at all stages of the API lifecycle is essential for reducing redundancy across operations, helping teams find existing APIs before they develop new ones, properly matching API consumers with the right APIs, while supporting documentation, relevant workflows, and the feedback loops that exist as part of the operation of APIs internally within the enterprise, or externally with 3rd party developers. API discovery does not live at the beginning or the end of the API lifecycle, but should be considered across all areas of the API lifecycle, ensuring that APIs, as well as the operations around them are as discoverable as possible, but well informed when it comes to privacy, security, and terms of service.","elements":[{"name":"Search","label":"Search","context":1},{"name":"Private Network","label":"Private Network","context":1},{"name":"Public Network","label":"Public Network","context":1}]}],
"discussion": "https://github.com/postman-open-technologies/lifecycle/discussions/28",
"yaml": "https://github.com/postman-open-technologies/lifecycle/blob/main/_blueprints/creating-a-new-graphql-api.md",
"roles": ["Advocate","Architect","Backend","DevOps","Engineering","Frontend","Mobile","Product","Support","Writers"],
"content": "&lt;p&gt;GraphQL has emerged as an optimal way to expose databases as a robust API which can support the needs of modern web and mobile applications. Providing an approach to delivering a single API path that provides access to an entire data graph, allowing consumers to define their own queries, and receive exactly the response they need for whatever need they have in their particular application. This is a blueprint to walk through creating a new GraphQL API, while also establishing a well-defined lifecycle around the API, ensuring that it is well documented, tested, and provides a level of service that meets the business objectives of an organization.&lt;/p&gt;"
}
,

{
"name": "Design Review",
"version": "2021-09-11",
"description": "",
"conclusion": "This blueprint is meant to provide a standardized approach to automating API design reviews across operations as part of a standardized API lifecycle. Each element within this blueprint works to provide a simple overview of what is involved across the entire life of an API, with more detail present on the detail page for each element (if you are viewing this on the API lifecycle project site). If you are reading this via a PDF or printed version you can visit the landing page for this blueprint to access more information and view specific actions you might possibly consider taking as part of applying each element of this proposed lifecycle within your own operations. This blueprint is a living document and will continue to evolve and be added to over time based upon feedback from readers. If you have any questions, feedback, or feel like there is more information you need, feel free to jump on the Github discussion for this blueprint, or any of the individual elements present--the value this blueprint provides is actively defined by the feedback community members like you.",
"image": "test-automation.png",
"tags": ["OpenAPI","Design-First"],
"stage": "Governance",
"type": "sync",
"order": 1,
"status": "",
"maturity": "draft",
"version": "2021-09-11",
"areas": [{"label":"Define","description":"Each API being submitted as part of an API design review process should possess the necessary artifacts and elements needed to properly evaluate the design of each API. To ensure the API design review is as efficient and effective as possible it helps to have a dedicated location for the review to happen, with everything present to to conduct review, and provide feedback around the API, as well as supporting elements. Setting the stage for a speedy but effective review, sending an API back development, or allowing it to move everything forward to production.","image":"images/lifecycle-arrow-define.png","elements":[{"name":"Team Workspace","label":"Team Workspace","context":1},{"name":"Team Members","label":"Team Members","context":1},{"name":"Github Repository","label":"Github Repository","context":1},{"name":"Design Rules","label":"Design Rules","context":1},{"name":"OpenAPI","label":"OpenAPI","context":1},{"name":"Reference Documentation","label":"Reference Documentation","context":1},{"name":"Examples","label":"Examples","context":1},{"name":"Mock Server","label":"Mock Server","context":1},{"name":"Examples","label":"Examples","context":1},{"name":"Contract Testing","label":"Contract Testing","context":1}]},{"label":"Process","image":"images/lifecycle-arrow-test.png","description":"Once ready, with all the needed artifacts and element, an API should be submitted to a well defined process for reviewing the design of an API, then providing feedback on the state of an API, and whether it is ready for production, in as short of time as possible. Reaching a desireable outcome that upholds an organization's design guidelines, and helps make teams better at what they do. Ensuring that eery API design review is a learning opportunity for both designer and reviewer. Continuing to improve the API design process with each API submitted for review, making operations incrementally better along the way.","elements":[{"name":"Design Review","label":"Design Review"},{"name":"Design Review Timeline","label":"Design Review Timeline"},{"name":"Design Review Feedback","label":"Design Review Feedback"},{"name":"Design Review Outcomes","label":"Design Review Outcomes"}]}],
"discussion": "https://github.com/postman-open-technologies/lifecycle/discussions/33",
"yaml": "https://github.com/postman-open-technologies/lifecycle/blob/main/_blueprints/test-automation.md",
"roles": ["Architect","Backend","DevOps","Engineering","Frontend","Mobile","Product","Support","Writers"],
"content": "&lt;p&gt;This blueprint works to provide a high level walk-through what an API design review process can look like. API design reviews give pause before any API goes into to production to make sure every APIs meets the design standards of an organization. Designers and developers should have a wealth of resources to help them design the best possible API before it gets submitted, but the injection of the design process ensures that each API gets attention from designer reviewers, architects, and anyone else who might speak to the value an API should deliver, and the needs of consumers. APIs design processes will make your APIs better, your teams better, and your overall organization better at doing what it does best.&lt;/p&gt;"
}
,

{
"name": "Discovery",
"version": "2021-11-24",
"description": "",
"conclusion": "Text",
"image": "workflow.png",
"tags": ["Requests"],
"stage": "Automation",
"type": "sync",
"order": 1,
"status": "draft",
"maturity": "optimized",
"version": "2021-11-24",
"areas": [{"label":"Components","description":"Text","image":"images/lifecycle-arrow-define.png","elements":[{"name":"Workspaces","label":"Workspaces"},{"name":"APIs","label":"APIs"},{"name":"Documentation","label":"Documentation"},{"name":"Mock Servers","label":"Mock Servers"},{"name":"Tests","label":"Tests"},{"name":"Monitors","label":"Monitors"}]},{"label":"Mechanism","description":"Text","image":"images/lifecycle-arrow-define.png","elements":[{"name":"Search","label":"Search"},{"name":"Browse","label":"Browse"}]},{"label":"Visibility","description":"Text","image":"images/lifecycle-arrow-define.png","elements":[{"name":"Private","label":"Private"},{"name":"Partner","label":"Partner"},{"name":"Public","label":"Public"}]},{"label":"Purpose","description":"Text","image":"images/lifecycle-arrow-define.png","elements":[{"name":"New APIs","label":"New APIs"},{"name":"New Applications","label":"New Applications"},{"name":"New Integrations","label":"New Integrations"}]}],
"discussion": "",
"yaml": "",
"roles": ["Advocate","Architect","CIO","CISO","CTO","Engineering","Product"],
"content": ""
}
,

{
"name": "Documentation",
"version": "2021-11-24",
"description": "",
"conclusion": "Text",
"image": "workflow.png",
"tags": ["Documentation","Examples","Snippets"],
"stage": "Automation",
"type": "sync",
"order": 1,
"status": "draft",
"maturity": "optimized",
"version": "2021-11-24",
"areas": [{"label":"Components","description":"Text","image":"images/lifecycle-arrow-define.png","elements":[{"name":"Documentation Title","label":"Documentation Title"},{"name":"Documentation Description","label":"Documentation Description"},{"name":"Documentation Requests","label":"Documentation Requests"},{"name":"Documentation Examples","label":"Documentation Examples"},{"name":"Documentation Snippets","label":"Documentation Snippets"}]},{"label":"Engagement","description":"Text","image":"images/lifecycle-arrow-define.png","elements":[{"name":"Collection URL","label":"Collection URL"},{"name":"Collection Button","label":"Collection Button"},{"name":"Collection Watch","label":"Collection Watch"},{"name":"Collection Fork","label":"Collection Fork"},{"name":"Collection Pull Request","label":"Collection Pull Request"},{"name":"Collection Merge","label":"Collection Merge"}]}],
"discussion": "",
"yaml": "",
"roles": ["Advocate","Architect","CIO","CISO","CTO","Engineering","Product"],
"content": ""
}
,

{
"name": "Everything but the Kitchen Sink",
"version": "2021-09-11",
"description": "",
"conclusion": "",
"image": "everything.png",
"tags": ["Default"],
"stage": "Template",
"type": "sync",
"order": 1,
"status": "",
"maturity": "draft",
"version": "2021-09-11",
"areas": [{"label":"Define","description":"Ensuring that operations supporting an API is properly defined, as well as what is needed to properly design and bring an API to life. A little planning and organization at this step of an APIs journey can go a long way towards ensuring the overall health and velocity of an API, and the applications that depend on this internal, partner, or public API.","image":"images/lifecycle-arrow-define.png","elements":[{"name":"Overview","label":"Overview"},{"name":"Private Workspace","label":"Private Workspace"},{"name":"Team Workspace","label":"Team Workspace"},{"name":"Partner Workspace","label":"Partner Workspace"},{"name":"Public Workspace","label":"Public Workspace"},{"name":"Team","label":"Team"},{"name":"Roles","label":"Roles"},{"name":"Github Repository","label":"Github Repository"},{"name":"Bitbucket Repository","label":"Bitbucket Repository"},{"name":"Gitlab Repository","label":"Gitlab Repository"},{"name":"Use Cases","label":"Use Cases"},{"name":"Goals","label":"Goals"},{"name":"Relationships","label":"Relationships"},{"name":"Environments","label":"Environments"},{"name":"Schema","label":"Schema"},{"name":"Examples","label":"Examples"},{"name":"Data Sources","label":"Data Sources"},{"name":"Role Based Access Control","label":"Role Based Access Control"},{"name":"OpenAPI","label":"OpenAPI"},{"name":"AsyncAPI","label":"AsyncAPI"},{"name":"WSDL","label":"WSDL"},{"name":"Scripts","label":"Scripts"}]},{"label":"Design","description":"Having a formal process and approach to designing an API helps establish consistency and the precision of APIs in production, ensuring that APIs are developed using common patterns across an industry, and within an organization, establishing known practices for shaping the surface area and behaviors of APIs that applications are depending upon.","image":"images/lifecycle-arrow-design.png","elements":[{"name":"Prototype Collection","label":"Prototype Collection"},{"name":"Workflow Collection","label":"Workflow Collection"},{"name":"OpenAPI","label":"OpenAPI"},{"name":"AsyncAPI","label":"AsyncAPI"},{"name":"WSDL","label":"WSDL"},{"name":"Design Patterns","label":"Design Patterns"}]},{"label":"Mock","description":"Mocking how an API works and behaves provides an effective way for teams to collaborate, communicate, and iterate as part of the design of an API, but also is something that can be used as part of testing, or just providing a sandbox environment for API consumers to learn before they actually begin working with any API in production.","image":"images/lifecycle-arrow-mock.png","elements":[{"name":"Mock Server","label":"Mock Server"},{"name":"Examples","label":"Examples"}]},{"label":"Document","description":"Having complete, accurate, and easy to follow document is essential for all APIs, helping alleviate the number one pain point for API consumers when it comes to onboarding with an API, as well as expanding the number of API paths an application puts to work, making API documentation one of the most important areas of the API lifecycle.","image":"images/lifecycle-arrow-document.png","elements":[{"name":"Reference Documentation","label":"Reference Documentation"},{"name":"Onboarding Documentation","label":"Onboarding Documentation"},{"name":"Workflow Documentation","label":"Workflow Documentation"},{"name":"Examples","label":"Examples"},{"name":"Code Annotations","label":"Code Annotations"},{"name":"Interceptor","label":"Interceptor"},{"name":"Proxy","label":"Proxy"}]},{"label":"Test","description":"A test-driven API lifecycle ensures that each API accomplishes the intended purpose it was developed for, providing manual and automated ways to ensure an API hasn't changed unexpectedly, is as performant as required, and meets the security expectations of everyone involved, helping establish a high quality of service consistently across all APIs.","image":"images/lifecycle-arrow-test.png","elements":[{"name":"Contract Testing","label":"Contract Testing"},{"name":"Performance Testing","label":"Performance Testing"},{"name":"Security Testing","label":"Security Testing"},{"name":"Workflow Testing","label":"Workflow Testing"},{"name":"Uptime Testing","label":"Uptime Testing"},{"name":"Integration Testing","label":"Integration Testing"},{"name":"Linting","label":"Linting"},{"name":"Scripts","label":"Scripts"}]},{"label":"Deploy","description":"Establishing a well defined process for deploy an API helps teams deploy new APIs, as well as each future iteration of an API in a consistent and repeatable way, making sure APIs are deployed using known development, staging, production, other agreed upon stages that actively put to work the other elements like documentation, testing, while contributing to observability.","image":"images/lifecycle-arrow-deploy.png","elements":[{"name":"Pipeline","label":"Pipeline"},{"name":"Gateway","label":"Gateway"},{"name":"Business Logic","label":"Business Logic"},{"name":"Resolvers","label":"Resolvers"}]},{"label":"Code","description":"Providing either server or client side code that helps make it easier to produce, consume, and integrate with APIs, helping reduce friction and increase velocity of teams by providing many of the common needs developers will need to put APIs to work across operations.","image":"images/lifecycle-arrow-code.png","elements":[{"name":"Code","label":"Code"},{"name":"Client SDKs","label":"Client SDKs"},{"name":"Client Snippets","label":"Client Snippets"}]},{"label":"Manage","description":"APIs should be managed using a set of common, well-defined policies that define and govern how APIs are access via all stages of the lifecycle, and ensure that every API has relevant authentication, rate limits, logging, and other essential aspects of managing APIs at scale, helping strike a balance between making APIs accessible and the privacy and security concerns that exist.","image":"images/lifecycle-arrow-manage.png","elements":[{"name":"Onboarding","label":"Onboarding"},{"name":"Authentication","label":"Authentication"},{"name":"Usage Plan","label":"Usage Plan"},{"name":"Key","label":"Key"},{"name":"Applications","label":"Applications"},{"name":"Automation","label":"Automation"},{"name":"Client","label":"Client"}]},{"label":"Monitor","description":"All tests applied to an API should be monitored on a logical schedule and from relevant geographic regions, monitoring that APIs aren't breaking their contract, falling below their agreed upon service level agreement (SLA), or becoming a security risk, helping automate the quality of service across APIs in a way that allows teams to be as productive as possible.","image":"images/lifecycle-arrow-monitor.png","elements":[{"name":"Monitor","label":"Monitor"},{"name":"Contract Testing Monitor","label":"Contract Testing Monitor"},{"name":"Contract Testing Monitor Results","label":"Contract Testing Monitor Results"},{"name":"Performance Testing Monitor","label":"Performance Testing Monitor"},{"name":"Performance Testing Monitor Results","label":"Performance Testing Monitor Results"},{"name":"Security Testing Monitor","label":"Security Testing Monitor"},{"name":"Security Testing Monitor Results","label":"Security Testing Monitor Results"},{"name":"Workflow Testing Monitor","label":"Workflow Testing Monitor"},{"name":"Workflow Testing Monitor Results","label":"Workflow Testing Monitor Results"},{"name":"Integration Testing Monitor","label":"Integration Testing Monitor"},{"name":"Integration Testing Monitor Results","label":"Integration Testing Monitor Results"},{"name":"Uptime Testing Monitor Results","label":"Uptime Testing Monitor Results"}]},{"label":"Automation","description":"Automating producing or consumption of API resources and capabilities, allowing for repeatable API-driven process to be triggered, scheduled, or respond to events, allowing for teams to properly define and set into motions certain aspects of operations while they focus on the more manual, creative, and human aspects of doing APIs.","image":"images/lifecycle-arrow-security.png","elements":[{"name":"Monitor","label":"Monitor"},{"name":"Scripts","label":"Scripts"},{"name":"Newman","label":"Newman"}]},{"label":"Discover","description":"The ability to discover APIs at all stages of the API lifecycle is key to reduce redundancy across operations, helping teams find existing APIs before they develop new ones, and properly match API consumers with the right APIs, supporting documentation, relevant workflows, and the feedback loops that exist as part of the operation of APIs internally within the enterprise, or externally with 3rd party developers.","image":"images/lifecycle-arrow-discover.png","elements":[{"name":"Private Network","label":"Private Network"},{"name":"Public Network","label":"Public Network"},{"name":"Search","label":"Search"}]},{"label":"Security","description":"Ensuring that all digital resources and capabilities are properly secured from end to end, making sure proper identity and access management, vulnerability scanning, and other common approaches to securing infrastructure on the Internet is in place and properly maintained.","image":"images/lifecycle-arrow-security.png","elements":[{"name":"Secure","label":"Secure"},{"name":"Role Based Access Control","label":"Role Based Access Control"},{"name":"Authentication","label":"Authentication"},{"name":"Security Testing","label":"Security Testing"}]},{"label":"Observability","description":"Tapping into the outputs available across API operations to understand what is happening with individual APIs throughout their lifecycle, but also in aggregate for domains, teams, and other logical groups, helping make API operations more visible in real time.","image":"images/lifecycle-arrow-observability.png","elements":[{"name":"Activity","label":"Activity"},{"name":"Reports","label":"Reports"},{"name":"Change Log","label":"Change Log"},{"name":"Audit","label":"Audit"},{"name":"Uptime Monitor Report","label":"Uptime Monitor Report"},{"name":"Gateway Usage Report","label":"Gateway Usage Report"},{"name":"Security Monitor Report","label":"Security Monitor Report"},{"name":"Contract Testing Monitor Report","label":"Contract Testing Monitor Report"},{"name":"Performance Monitor Report","label":"Performance Monitor Report"},{"name":"Integration Monitor Report","label":"Integration Monitor Report"},{"name":"Application Performance Management (APM)","label":"Application Performance Management (APM)"},{"name":"Workflow Monitor Report","label":"Workflow Monitor Report"},{"name":"Intelligence","label":"Intelligence"}]},{"label":"Communicate","description":"Communicate with API stakeholders syncronously and asyncronously across the API lifecycle, localizing the conversation around what is happening around each API, while also allowing for seamless integration with exiting communication channels, allowing teams to efficiently share knowledge in the moment.","image":"images/lifecycle-arrow-communications.png","elements":[{"name":"Notifications","label":"Notifications"},{"name":"Comments","label":"Comments"},{"name":"Inform","label":"Inform"}]},{"label":"Collaborate","description":"Collaborating across teams and lines of business to securely share artifacts from across API operations, providing more visibility across the workspaces where developers are already producing and consuming APIs, while providing many different types of collaboration opportunities as they work.","image":"images/lifecycle-arrow-collaborate.png","elements":[{"name":"Sharing","label":"Sharing"},{"name":"Watching","label":"Watching"},{"name":"Forking","label":"Forking"},{"name":"Inviting","label":"Inviting"},{"name":"Mentions","label":"Mentions"}]},{"label":"Governance","description":"Defining all the practices and process across the organization for delivering APIs, establishing well known and communicated areas, elements, and actions that shape how API operations function, providing all teams with what they need to effectively deliver API infrastructure from start to finish.","image":"images/lifecycle-arrow-governance.png","elements":[{"name":"Design Patterns","label":"Design Patterns"},{"name":"Documentation Rules","label":"Documentation Rules"},{"name":"Management Rules","label":"Management Rules"},{"name":"Linting","label":"Linting"}]},{"label":"Retire","description":"Having a plan for the eventual retirement and ultimate deprecation of an API, or for specific paths or versions of an API should be a part of every API lifecycle, even when there is no plan for deprecation there should be a process in place for setting expectations for how long an API will be supported, as well as formal process to follow once retirement comes into view on the horizon.","image":"images/lifecycle-arrow-retire.png","elements":[{"name":"Retire","label":"Retire"},{"name":"Deprecate","label":"Deprecate"},{"name":"Archive","label":"Archive"}]}],
"discussion": "https://github.com/postman-open-technologies/lifecycle/discussions/20",
"yaml": "https://github.com/postman-open-technologies/lifecycle/blob/main/_blueprints/everything.md",
"roles": null,
"content": "&lt;p&gt;At vero eos et accusamus et iusto odio dignissimos ducimus qui blanditiis praesentium voluptatum deleniti atque corrupti quos dolores et quas molestias excepturi sint occaecati cupiditate non provident, similique sunt in culpa qui officia deserunt mollitia animi, id est laborum et dolorum fuga. Et harum quidem rerum facilis est et expedita distinctio. Nam libero tempore, cum soluta nobis est eligendi optio cumque nihil impedit quo minus id quod maxime placeat facere possimus, omnis voluptas assumenda est, omnis dolor repellendus. Temporibus autem quibusdam et aut officiis debitis aut rerum necessitatibus saepe eveniet ut et voluptates repudiandae sint et molestiae non recusandae. Itaque earum rerum hic tenetur a sapiente delectus, ut aut reiciendis voluptatibus maiores alias consequatur aut perferendis doloribus asperiores repellat.&lt;/p&gt;"
}
,

{
"name": "Generate Collection From Mobile Application API",
"version": "2021-09-11",
"description": "",
"conclusion": "This blueprint intends to provide a look at how you can bring an API into a standardized API lifecycle by reverse engineering API traffic behind a mobile application using a proxy  Each element within this blueprint works to provide a simple overview of what is involved across the entire life of an API, with more detail present on the detail page for each element (if you are viewing this on the API lifecycle project site). If you are reading this via a PDF or printed version you can visit the landing page for this blueprint to access more information and view specific actions you might possibly consider taking as part of applying each element of this proposed lifecycle within your own operations. This blueprint is a living document and will continue to evolve and be added to over time based upon feedback from readers. If you have any questions, feedback, or feel like there is more information you need, feel free to jump on the Github discussion for this blueprint, or any of the individual elements present--the value this blueprint provides is actively defined by the feedback community members like you.",
"image": "mobile-application.png",
"tags": ["OpenAPI","Prototype-First"],
"stage": "Reverse",
"type": "sync",
"order": 7,
"status": "",
"maturity": "stable",
"version": "2021-09-11",
"areas": [{"label":"Define","image":"images/lifecycle-arrow-define.png","description":"Ensuring that operations supporting an API is properly defined, as well as what is needed to properly design and bring an API to life. A little planning and organization at this step of an APIs journey can go a long way towards ensuring the overall health and velocity of an API, and the applications that depend on this internal, partner, or public API.","elements":[{"name":"Proxy","label":"Proxy"},{"name":"Traffic Collection","label":"Traffic Collection"}]},{"label":"Document","image":"images/lifecycle-arrow-document.png","description":"Having complete, accurate, and easy to follow document is essential for all APIs, helping alleviate the number one pain point for API consumers when it comes to onboarding with an API, as well as expanding the number of API paths an application puts to work, making API documentation one of the most important areas of the API lifecycle.","elements":[{"name":"Reference Documentation","label":"Reference Documentation"}]},{"label":"Test","image":"images/lifecycle-arrow-test.png","description":"A test-driven API lifecycle ensures that each API accomplishes the intended purpose it was developed for, providing manual and automated ways to ensure an API hasn't changed unexpectedly, is as performant as required, and meets the security expectations of everyone involved, helping establish a high quality of service consistently across all APIs.","elements":[{"name":"Contract Testing","label":"Contract Testing"},{"name":"Performance Testing","label":"Performance Testing"},{"name":"Security Testing","label":"Security Testing"}]},{"label":"Monitor","image":"images/lifecycle-arrow-monitor.png","description":"All tests applied to an API should be monitored on a logical schedule and from relevant geographic regions, monitoring that APIs aren't breaking their contract, falling below their agreed upon service level agreement (SLA), or becoming a security risk, helping automate the quality of service across APIs in a way that allows teams to be as productive as possible.","elements":[{"name":"Contract Monitor","label":"Contract Monitor"},{"name":"Performance Monitor","label":"Performance Monitor"},{"name":"Security Monitor","label":"Security Monitor"}]},{"label":"Discover","image":"images/lifecycle-arrow-discover.png","description":"The ability to discover APIs at all stages of the API lifecycle is key to reduce redundancy across operations, helping teams find existing APIs before they develop new ones, and properly match API consumers with the right APIs, supporting documentation, relevant workflows, and the feedback loops that exist as part of the operation of APIs internally within the enterprise, or externally with 3rd party developers.","elements":[{"name":"Private Network","label":"Private Network"},{"name":"Public Network","label":"Public Network"},{"name":"Search","label":"Search"}]}],
"discussion": "https://github.com/postman-open-technologies/lifecycle/discussions/10",
"yaml": "https://github.com/postman-open-technologies/lifecycle/blob/main/_blueprints/generate-collection-from-mobile-application.md",
"roles": ["Advocate","Architect","Backend","DevOps","Engineering","Frontend","Mobile","Product","Support","Writers"],
"content": "&lt;p&gt;Mobile applications are often developed rapidly using APIs without much consideration for how those APIs will be used beyond the current project. Mobile applications are often developed by teams and contractors who may not have exposure to the standardized development of APIs within an organization which would allow for APIs to be reused across multiple applications and integrations. A recurring situation that will make it necessary to reverse engineer the APIs behind a mobile application, generate a collection, documentation, and establish testing and monitors that help provide more observability into what is happening with API infrastructure behind the mobile applications we depend on. Postman provides a proxy for routing mobile traffic and generating a collection that describes the surface area of requests and responses, allowing it to be cleaned up, documented, then available for testing, monitoring, and discovery. Providing a powerful way to reverse engineer existing APIs behind mobile applications, but them make them more visible and reusuable across an organization, helping eliminate redundancy across operations.&lt;/p&gt;"
}
,

{
"name": "Generate Collection From Web Application API",
"version": "2021-09-11",
"description": "",
"conclusion": "This blueprint intends to provide a look at how you can bring an API into a standardized API lifecycle by reverse engineering API traffic using Postman Interceptor. Each element within this blueprint works to provide a simple overview of what is involved across the entire life of an API, with more detail present on the detail page for each element (if you are viewing this on the API lifecycle project site). If you are reading this via a PDF or printed version you can visit the landing page for this blueprint to access more information and view specific actions you might possibly consider taking as part of applying each element of this proposed lifecycle within your own operations. This blueprint is a living document and will continue to evolve and be added to over time based upon feedback from readers. If you have any questions, feedback, or feel like there is more information you need, feel free to jump on the Github discussion for this blueprint, or any of the individual elements present--the value this blueprint provides is actively defined by the feedback community members like you.",
"image": "web-application.png",
"tags": ["OpenAPI","Prototype-First"],
"stage": "Reverse",
"type": "sync",
"order": 6,
"status": "",
"maturity": "stable",
"version": "2021-09-11",
"areas": [{"label":"Define","image":"images/lifecycle-arrow-define.png","description":"Ensuring that operations supporting an API is properly defined, as well as what is needed to properly design and bring an API to life. A little planning and organization at this step of an APIs journey can go a long way towards ensuring the overall health and velocity of an API, and the applications that depend on this internal, partner, or public API.","elements":[{"name":"Interceptor","label":"Interceptor"},{"name":"Traffic Collection","label":"Traffic Collection"}]},{"label":"Document","image":"images/lifecycle-arrow-document.png","description":"Having complete, accurate, and easy to follow document is essential for all APIs, helping alleviate the number one pain point for API consumers when it comes to onboarding with an API, as well as expanding the number of API paths an application puts to work, making API documentation one of the most important areas of the API lifecycle.","elements":[{"name":"Reference Documentation","label":"Reference Documentation"}]},{"label":"Test","image":"images/lifecycle-arrow-test.png","description":"A test-driven API lifecycle ensures that each API accomplishes the intended purpose it was developed for, providing manual and automated ways to ensure an API hasn't changed unexpectedly, is as performant as required, and meets the security expectations of everyone involved, helping establish a high quality of service consistently across all APIs.","elements":[{"name":"Contract Testing","label":"Contract Testing"},{"name":"Performance Testing","label":"Performance Testing"},{"name":"Security Testing","label":"Security Testing"}]},{"label":"Monitor","image":"images/lifecycle-arrow-monitor.png","description":"All tests applied to an API should be monitored on a logical schedule and from relevant geographic regions, monitoring that APIs aren't breaking their contract, falling below their agreed upon service level agreement (SLA), or becoming a security risk, helping automate the quality of service across APIs in a way that allows teams to be as productive as possible.","elements":[{"name":"Contract Monitor","label":"Contract Monitor"},{"name":"Performance Monitor","label":"Performance Monitor"},{"name":"Security Monitor","label":"Security Monitor"}]},{"label":"Discover","image":"images/lifecycle-arrow-discover.png","description":"The ability to discover APIs at all stages of the API lifecycle is key to reduce redundancy across operations, helping teams find existing APIs before they develop new ones, and properly match API consumers with the right APIs, supporting documentation, relevant workflows, and the feedback loops that exist as part of the operation of APIs internally within the enterprise, or externally with 3rd party developers.","elements":[{"name":"Private Network","label":"Private Network"},{"name":"Public Network","label":"Public Network"},{"name":"Search","label":"Search"}]}],
"discussion": "https://github.com/postman-open-technologies/lifecycle/discussions/12",
"yaml": "https://github.com/postman-open-technologies/lifecycle/blob/main/_blueprints/generate-collection-from-web-application.md",
"roles": ["Advocate","Architect","Backend","DevOps","Engineering","Frontend","Mobile","Product","Support","Writers"],
"content": "&lt;p&gt;APIs behind web applications are often developed with it’s use beyond it’s immediate purpose within a single application, resulting in the need to reverse engineer, document, test, and move forward as a standardized API as part of a well known API lifecycle in the future. This is a common entry into the API lifecycle for an existing API, acknowledging that APIs will regularly be brought to life to support a specific need, but then eventually they should be standardized and made usable across multiple applications and integrations. The Postman Interceptor provides an effective way to capture traffic behind the web applications we use each day and route the traffic into a collection for cleaning up, documenting, and then potentially testing and monitoring as part of a formal API lifecycle. Providing a robust approach to rapidly mapping out API infrastructure behind our web applications, and then ensuring they are well documented and reliable for use beyond a single application.&lt;/p&gt;"
}
,

{
"name": "Generate OpenAPI Using Code Annotations",
"version": "2021-09-11",
"description": "",
"conclusion": "",
"image": "openapi.png",
"tags": ["OpenAPI","Code Annotations"],
"stage": "Existing",
"type": "sync",
"order": 5,
"status": "",
"maturity": "stable",
"version": "2021-09-11",
"areas": [{"label":"Define","description":"The most important first step of any API lifecycle is to make sure the operations around an API are properly defined, laying the foundation for being able to effectively design and bring an API to life, while also establishing a known place, or places to go to get all the information you need regarding each individual API, or groups of APIs. A little planning and organization at this early step of the API journey can go a long way towards ensuring the overall health and velocity of an API, and the applications and integrations that will depend on each internal, partner, or public API being delivered.","image":"images/lifecycle-arrow-define.png","elements":[{"name":"Team Workspace","label":"Team Workspace","context":1},{"name":"Team Members","label":"Team Members","context":1},{"name":"Github Repository","label":"Github Repository","context":1}]},{"label":"Deploy","image":"images/lifecycle-arrow-deploy.png","description":"The road to setting a new code-first or existing API on a road to a standardized API lifecycle often times begins with the generation of an OpenAPI from annotations in the code as part of a build process. Relying on annotations for each code method to produce an API for the surface area of the API, updating the OpenAPI, and other supporting documentation and tests using a CI/CD pipeline. Bypassing the API design process and going with a code-first approach to delivering an API, and relying on the pipeline for the existing software development lifecycle to generate the OpenAPI, and set in motion the delivery of documentation, testing, and other elements of the API lifecycle.","elements":[{"name":"CI/CD Pipeline","label":"CI/CD Pipeline","context":1},{"name":"Code Annotations","label":"Code Annotations","context":1},{"name":"OpenAPI","label":"OpenAPI","context":1}]},{"label":"Document","image":"images/lifecycle-arrow-document.png","description":"Having complete, accurate, and easy to follow documentation is essential for all APIs, and is something that  alleviates the number one pain point for API consumers when it comes to onboarding with any API, expanding the number of API paths an application puts to work. Modern approaches to producing API documentation have moved beyond a single static version of documentation simply published to a portal, as well as there being potentially multiple forms of documentation for any single API. Helping API producers onboard consumers easier, reduce the cognitive load when understanding what an API does, and properly define specific business use cases of an API being put to work in an application or as part of an integration.","elements":[{"name":"Reference Documentation","label":"Reference Documentation","context":1}]},{"label":"Test","image":"images/lifecycle-arrow-test.png","description":"A test-driven API lifecycle ensures that each API delivers the intended outcomes it was developed for in the first place, providing manual as well as automated ways to ensure an API hasn't changed unexpectedly and is as performant as required, helping establish a high quality of service consistently across all APIs. API testing should not be an afterthought and should be a default aspect of the API lifecycle for any API being put into production. API testing takes a solid investment in establishing proper testing practices across teams, but once you do the work to establish a baseline of testing, properly train teams on the process and tooling involved, the investment will pay off down the road.","elements":[{"name":"Contract Testing","label":"Contract Testing","context":1},{"name":"Performance Testing","label":"Performance Testing","context":1}]},{"label":"Secure","image":"images/lifecycle-arrow-test.png","description":"Security must be its own area of the API lifecycle, but it is something that should span testing, authentication, and potentially other areas of the API lifecycle. Over the last five years the world of API security has expanded, while also moving further left in the API lifecycle as part of a devops shift in how APIs are delivered. There are a number of elements present when it comes to security, but depending on the overall maturity of API operations the available resources and prioritization available to adequately realize these elements vary.","elements":[{"name":"Authentication","label":"Authentication","context":1},{"name":"Security Testing","label":"Security Testing","context":1}]},{"label":"Monitor","image":"images/lifecycle-arrow-monitor.png","description":"Monitors can be used to execute any Postman collection applied to any environment. Due to the versatility of what a Postman collection can define, collections turn monitors into a powerful API automation and orchestration tool. Beginning with the ability to schedule contract, performance, and other types of tests, but then also allowing for automating specific workflows across many different APIs. Since collections can be used to define anything that can be defined via an API, monitors can be used to schedule the running of each capability from multiple cloud regions, applying many different environmental variables. Making monitors an essential, versatile, and executable part of defining how the API lifecycle works.","elements":[{"name":"Contract Testing Monitor","label":"Contract Testing Monitor","context":1},{"name":"Performance Testing Monitor","label":"Performance Testing Monitor","context":1},{"name":"Security Testing Monitor","label":"Security Testing Monitor","context":1}]},{"label":"Discover","image":"images/lifecycle-arrow-discover.png","description":"The ability to discover APIs at all stages of the API lifecycle is essential for reducing redundancy across operations, helping teams find existing APIs before they develop new ones, properly matching API consumers with the right APIs, while supporting documentation, relevant workflows, and the feedback loops that exist as part of the operation of APIs internally within the enterprise, or externally with 3rd party developers. API discovery does not live at the beginning or the end of the API lifecycle, but should be considered across all areas of the API lifecycle, ensuring that APIs, as well as the operations around them are as discoverable as possible, but well informed when it comes to privacy, security, and terms of service.","elements":[{"name":"Search","label":"Search","context":1},{"name":"Private Network","label":"Private Network","context":1},{"name":"Public Network","label":"Public Network","context":1}]}],
"discussion": "https://github.com/postman-open-technologies/lifecycle/discussions/15",
"yaml": "https://github.com/postman-open-technologies/lifecycle/blob/main/_blueprints/generate-openapi-from-code-annotations.md",
"roles": ["Advocate","Architect","Backend","DevOps","Engineering","Frontend","Mobile","Product","Support","Writers"],
"content": "&lt;p&gt;Not all APIs and the teams developing them are able to embrace a design first approach to delivering APIs and sometimes it makes more sense for developers to write the code first, then provide annotations within the code that can be used to generate OpenAPI definitions for each API as part of the regular build process. It is important that there is an OpenAPI contract for each API, so that documentation, mocks, testing, and other elements can be generated, but not all teams will be able to hand-craft the OpenAPI from scratch. Making code annotations a valid approach to developing an API using a code-first approach, but still realizing the benefits of having an up to date machine readable contract present for each API as it evolves throughout the lifecycle.&lt;/p&gt;"
}
,

{
"name": "High Level API Governance",
"version": "2021-09-12",
"description": "",
"conclusion": "This blueprint looks at how you can approach API governance as an organization, establishing high level strategy and practices that can be used to direct governance efforts across teams. Each element within this blueprint works to provide a simple overview of what is involved across the entire life of an API, with more detail present on the detail page for each element (if you are viewing this on the API lifecycle project site). If you are reading this via a PDF or printed version you can visit the landing page for this blueprint to access more information and view specific actions you might possibly consider taking as part of applying each element of this proposed lifecycle within your own operations. This blueprint is a living document and will continue to evolve and be added to over time based upon feedback from readers. If you have any questions, feedback, or feel like there is more information you need, feel free to jump on the Github discussion for this blueprint, or any of the individual elements present--the value this blueprint provides is actively defined by the feedback community members like you.",
"image": "governance.png",
"tags": ["OpenAPI","Governance"],
"stage": "Governance",
"type": "sync",
"order": 1,
"status": "",
"maturity": "draft",
"version": "2021-09-12",
"areas": [{"label":"Define","description":"API governance needs to be well defined, beginning with defining the overall API lifecycle, which this project is dedicated to doing, and the establishment of a formal strategy. Without properly defining of what governance is, and how it will be applied across the API lifecycle, it will never be realized. To establish API governance at the highest levels within an organization you need a well defined view of what is happening today across operations, and coherent articulation of where we should be going. This definition will not every e complete, but more of an ongoing journey for an organization to define itself.","image":"images/lifecycle-arrow-define.png","elements":[{"name":"API Lifecycle","label":"API Lifecycle"},{"name":"Governance Strategy","label":"Governance Strategy"}]},{"label":"Organization","image":"images/lifecycle-arrow-design.png","description":"The structure and leadership of governance will need to be established for API governance to move forward at the highest levels, otherwise it will just be a low-level vision that a handful of teams are able to realize. The organization of governance needs to reflect the organization where it is being applied in order to have greatest impact. To do this, you have to invest resources, time, and people to helping organize, lead, and guide teams in learning about, understanding, applying, reporting, and providing feedback on what is working and what is not working when it comes to governance.","elements":[{"name":"Governance Structure","label":"Governance Structure"},{"name":"Governance Leadership","label":"Governance Leadership"},{"name":"Governance Guidelines","label":"Governance Guidelines"}]},{"label":"Rules","image":"images/lifecycle-arrow-document.png","description":"API governance rules codifies what API governance is as it is applied as part of the design, development and build process on the ground floor of API operations. Rules provide the benchmark for what governance is across teams, and provide an artifact that can be applied across the API lifecycle by individual designers and developers, and eventually baked into the pipelines that move API infrastructure forward. Rules should reflect what is happening on the ground today, but apply enforcement as part of a forward motion, acknowledging that legacy APIs may not always rise to the level governance an organization is moving towards.","elements":[{"name":"Design Rules","label":"Design Rules"},{"name":"Documentation Rules","label":"Documentation Rules"},{"name":"Management Rules","label":"Management Rules"},{"name":"Testing Rules","label":"Testing Rules"}]},{"label":"Reporting","image":"images/lifecycle-arrow-monitor.png","description":"Reporting on the realities and outcomes of API governance across the API lifecycle is needed to make it more visual and tangible for everyone involved. Reporting across governance being applied to individual APIs, groups of APIs, and overall operations can be realized as part of native platform reporting, customized, localized or in aggregate with Postman Visualizer, or made seamless with existing operations by piping data into APM and other systems to make available for reporting and visualizations via dashboards.","elements":[{"name":"Reports","label":"Reports"},{"name":"Visualizer","label":"Visualizer"},{"name":"Application Performance Management (APM)","label":"Application Performance Management (APM)"}]}],
"discussion": "https://github.com/postman-open-technologies/lifecycle/discussions/45",
"yaml": "https://github.com/postman-open-technologies/lifecycle/blob/main/_blueprints/low-level-governance.md",
"roles": ["Advocate","Architect","CIO","CISO","CTO","Engineering","Product","Security"],
"content": "&lt;p&gt;A standardized API lifecycle can be applied to the design, development, and usage of API business workflows that are defined as machine readable collections which can be automated using monitors and CI/CD pipelines. Postman collections provide a versatile approach to defining multiple individual API requests that include authentication, parameters, headers, and other details, then organize into folders and specific sequences. Providing a format for defining, documenting, but then also executing common business workflows across many internal, partner, or external APIs. Something becomes endlessly useful when managed as part of a well defined lifecycle, equipping developers with what they need to define and design the workflows, but also maintain them, execute them, and use them to automate a variety of business tasks that exist in their worlds.&lt;/p&gt;"
}
,

{
"name": "Import WSDL for an Existing SOAP Web Service",
"version": "2021-09-11",
"description": "",
"conclusion": "This blueprint intends to provide a high level walk through of one possible way of defining a standardized API lifecycle which is centered around an existing SOAP web service. Each element within this blueprint works to provide a simple overview of what is involved across the entire life of an API, with more detail present on the detail page for each element (if you are viewing this on the API lifecycle project site). If you are reading this via a PDF or printed version you can visit the landing page for this blueprint to access more information and view specific actions you might possibly consider taking as part of applying each element of this proposed lifecycle within your own operations. This blueprint is a living document and will continue to evolve and be added to over time based upon feedback from readers. If you have any questions, feedback, or feel like there is more information you need, feel free to jump on the Github discussion for this blueprint, or any of the individual elements present--the value this blueprint provides is actively defined by the feedback community members like you.",
"image": "wsdl.png",
"tags": ["WSDL","SOAP","Web Service"],
"stage": "Existing",
"type": "sync",
"order": 7,
"status": "",
"maturity": "stable",
"version": "2021-09-11",
"areas": [{"label":"Define","image":"images/lifecycle-arrow-define.png","description":"For traditional web services the web services description language (WSDL) is the key to defining and understanding what each API is capable of. Similar to an OpenAPI, the WSDL describes the surface area of a SOAP web service, defining the available methods and payload structure. Upon import or creation of a new API using WSDL, a modern API lifecycle can be set into motion through the generation of collections for documenting and testing of web services. Helping modernize existing web services by applying some of the common elements of modern API lifecycle to existing WSDL services.","elements":[{"name":"Team Workspace","label":"Team Workspace","context":1},{"name":"Team Members","label":"Team Members","context":1},{"name":"WSDL","label":"WSDL"}]},{"label":"Document","image":"images/lifecycle-arrow-document.png","description":"Having complete, accurate, and easy to follow documentation is essential for all APIs, and is something that  alleviates the number one pain point for API consumers when it comes to onboarding with any API, expanding the number of API paths an application puts to work. Modern approaches to producing API documentation have moved beyond a single static version of documentation simply published to a portal, as well as there being potentially multiple forms of documentation for any single API. Helping API producers onboard consumers easier, reduce the cognitive load when understanding what an API does, and properly define specific business use cases of an API being put to work in an application or as part of an integration.","elements":[{"name":"Reference Documentation","label":"Reference Documentation","context":1}]},{"label":"Test","image":"images/lifecycle-arrow-test.png","description":"A test-driven API lifecycle ensures that each API delivers the intended outcomes it was developed for in the first place, providing manual as well as automated ways to ensure an API hasn't changed unexpectedly and is as performant as required, helping establish a high quality of service consistently across all APIs. API testing should not be an afterthought and should be a default aspect of the API lifecycle for any API being put into production. API testing takes a solid investment in establishing proper testing practices across teams, but once you do the work to establish a baseline of testing, properly train teams on the process and tooling involved, the investment will pay off down the road.","elements":[{"name":"Contract Testing","label":"Contract Testing","context":1},{"name":"Performance Testing","label":"Performance Testing","context":1}]},{"label":"Secure","image":"images/lifecycle-arrow-test.png","description":"Security must be its own area of the API lifecycle, but it is something that should span testing, authentication, and potentially other areas of the API lifecycle. Over the last five years the world of API security has expanded, while also moving further left in the API lifecycle as part of a devops shift in how APIs are delivered. There are a number of elements present when it comes to security, but depending on the overall maturity of API operations the available resources and prioritization available to adequately realize these elements vary.","elements":[{"name":"Authentication","label":"Authentication","context":1},{"name":"Security Testing","label":"Security Testing","context":1}]},{"label":"Monitor","image":"images/lifecycle-arrow-monitor.png","description":"Monitors can be used to execute any Postman collection applied to any environment. Due to the versatility of what a Postman collection can define, collections turn monitors into a powerful API automation and orchestration tool. Beginning with the ability to schedule contract, performance, and other types of tests, but then also allowing for automating specific workflows across many different APIs. Since collections can be used to define anything that can be defined via an API, monitors can be used to schedule the running of each capability from multiple cloud regions, applying many different environmental variables. Making monitors an essential, versatile, and executable part of defining how the API lifecycle works.","elements":[{"name":"Contract Testing Monitor","label":"Contract Testing Monitor","context":1},{"name":"Performance Testing Monitor","label":"Performance Testing Monitor","context":1},{"name":"Security Testing Monitor","label":"Security Testing Monitor","context":1}]},{"label":"Discover","image":"images/lifecycle-arrow-discover.png","description":"The ability to discover APIs at all stages of the API lifecycle is essential for reducing redundancy across operations, helping teams find existing APIs before they develop new ones, properly matching API consumers with the right APIs, while supporting documentation, relevant workflows, and the feedback loops that exist as part of the operation of APIs internally within the enterprise, or externally with 3rd party developers. API discovery does not live at the beginning or the end of the API lifecycle, but should be considered across all areas of the API lifecycle, ensuring that APIs, as well as the operations around them are as discoverable as possible, but well informed when it comes to privacy, security, and terms of service.","elements":[{"name":"Search","label":"Search","context":1},{"name":"Private Network","label":"Private Network","context":1}]}],
"discussion": "https://github.com/postman-open-technologies/lifecycle/discussions/32",
"yaml": "https://github.com/postman-open-technologies/lifecycle/blob/main/_blueprints/import-wsdl-for-an-existing-soap-web-service.md",
"roles": ["Advocate","Architect","Backend","DevOps","Engineering","Frontend","Mobile","Product","Support","Writers"],
"content": "&lt;p&gt;Modern APIs and microservices is primarily delivered as RESTful, RPC, and GraphQL APIs using HTTP, but as the result of the widespread adoption of services oriented architecture (SOA) in the early 2000s, there are still many web services in production. SOAP is rarely used to deliver new APIs, but because of the ubiquitous nature of the approach within long living enterprise infrastructure, SOAP web services continue to play a significant role as part of API operations. This lifecycle blueprint acknowledges that existing SOAP web services have a place in the modern enterprise, and can benefit from some of the other healthy elements present across the API lifecycle for other types of APIs and microservices, ensuring they are well documented, have testing in place, as well as being monitored and discoverable just like the rest of API operations. This blueprint provides one possible path to consider as teams look to modernize their API infrastructure.&lt;/p&gt;"
}
,

{
"name": "Low Level API Governance",
"version": "2021-09-12",
"description": "",
"conclusion": "This blueprint looks at how you can approach API governance as an individual, learning about the building blocks of how governance can be applied when it comes to designing, developing, and operating individual APIs. Each element within this blueprint works to provide a simple overview of what is involved across the entire life of an API, with more detail present on the detail page for each element (if you are viewing this on the API lifecycle project site). If you are reading this via a PDF or printed version you can visit the landing page for this blueprint to access more information and view specific actions you might possibly consider taking as part of applying each element of this proposed lifecycle within your own operations. This blueprint is a living document and will continue to evolve and be added to over time based upon feedback from readers. If you have any questions, feedback, or feel like there is more information you need, feel free to jump on the Github discussion for this blueprint, or any of the individual elements present--the value this blueprint provides is actively defined by the feedback community members like you.",
"image": "governance.png",
"tags": ["OpenAPI","Governance"],
"stage": "Governance",
"type": "sync",
"order": 1,
"status": "",
"maturity": "draft",
"version": "2021-09-12",
"areas": [{"label":"Definition","description":"You can't govern what you don't have define, and to be able to begin governing the design of your APIs you will need to have machine readable artifacts that you can lint as part of the design, develop, or build process. Establishing a set of artifacts that help drive the API lifecycle, but also make it something that can be measured and reported upon as part of governance activities.","image":"images/lifecycle-arrow-define.png","elements":[{"name":"OpenAPI","label":"OpenAPI"},{"name":"AsyncAPI","label":"AsyncAPI"}]},{"label":"Application","image":"images/lifecycle-arrow-design.png","description":"Once you have an OpenAPI, AsyncAPI, or other artifact that you would like to apply governance too, there are a handful of ways in which you can execute governance as part of your regular work. Depending on your goals with governing the design of an API you can apply each of these elements helping manual or automatically identify problems with the design of your API. These approaches to execution are potentially dependent on other rules, as well as the approach you take to automating the application of governance.","elements":[{"name":"Rules-Based Linting","label":"Rules-Based Linting"},{"name":"Script-Based Governance","label":"Script-Based Governance"}]},{"label":"Rules","image":"images/lifecycle-arrow-document.png","description":"API governance rules codifies what API governance is as it is applied as part of the design, development and build process on the ground floor of API operations. Rules provide the benchmark for what governance is across teams, and provide an artifact that can be applied across the API lifecycle by individual designers and developers, and eventually baked into the pipelines that move API infrastructure forward. Rules should reflect what is happening on the ground today, but apply enforcement as part of a forward motion, acknowledging that legacy APIs may not always rise to the level governance an organization is moving towards.","elements":[{"name":"Info Governance Rules","label":"Info Governance Rules"},{"name":"Contact Governance Rules","label":"Contact Governance Rules"},{"name":"Versioning Governance Rules","label":"Versioning Governance Rules"},{"name":"Path Governance Rules","label":"Path Governance Rules"},{"name":"Operations Governance Rules","label":"Operations Governance Rules"},{"name":"Parameter Governance Rules","label":"Parameter Governance Rules"},{"name":"Request Bodies Governance Rules","label":"Request Bodies Governance Rules"},{"name":"Response Governance Rules","label":"Response Governance Rules"},{"name":"Schema Governance Rules","label":"Schema Governance Rules"},{"name":"Tags Governance Rules","label":"Tags Governance Rules"}]},{"label":"Automation","image":"images/lifecycle-arrow-test.png","description":"To realize governance across operations it is important that governance is applied in automated ways at different areas of the API lifecycle, helping ensure API governance can be applied early on in the lifecycle, but is also available throughout the development and delivery of aPIs, and when it makes sense bake it into the build process ensuring that governance is applied by default as every API moves into production. Helping ensure that teams aren't doing extra work to realize governance across operations, and it is just at their fingertips as they are design, developing, and building APIs as part of their regular day.","elements":[{"name":"Design Time Governance","label":"Design Time Governance"},{"name":"Collection Governance","label":"Collection Governance"},{"name":"CLI Governance","label":"CLI Governance"},{"name":"IDE Governance","label":"IDE Governance"},{"name":"Pipeline Governance","label":"Pipeline Governance"}]},{"label":"Reporting","image":"images/lifecycle-arrow-monitor.png","description":"Reporting on the realities and outcomes of API governance across the API lifecycle is needed to make it more visual and tangible for everyone involved. Reporting across governance being applied to individual APIs, groups of APIs, and overall operations can be realized as part of native platform reporting, customized, localized or in aggregate with Postman Visualizer, or made seamless with existing operations by piping data into APM and other systems to make available for reporting and visualizations via dashboards.","elements":[{"name":"Reports","label":"Reports"},{"name":"Visualizer","label":"Visualizer"},{"name":"Application Performance Management (APM)","label":"Application Performance Management (APM)"}]}],
"discussion": "https://github.com/postman-open-technologies/lifecycle/discussions/44",
"yaml": "https://github.com/postman-open-technologies/lifecycle/blob/main/_blueprints/low-level-governance.md",
"roles": ["Advocate","Architect","Backend","DevOps","Engineering","Frontend","Mobile","Product","Support","Writers"],
"content": "&lt;p&gt;Governance is best developed from the top town, establishing common processes, rules, and guidance that reflect the architectural and business interests of leadership, but governance is realized at the lowest levels on the ground floor of operations, and it also makes sense in many organizations to set in motion some low-level governance patterns while higher level governance is being established. This blueprint is meant to walk through how your average API developer might approach governance as part of their regular work, helping them design and deliver more consistence APIs as part of a more high level governance approach or in absence of a more high level governance approach. Helping API teams learn how to step back and look at how they can define what a good API is and then deliver on that vision consistently as part of a high velocity release schedule. Setting the stage for a low level approach to implementing API governance that can work in alignment with higher level strategy, or begin moving the API governance from the bottom up.&lt;/p&gt;"
}
,

{
"name": "Manually Define Collection for Existing API",
"version": "2021-09-11",
"description": "",
"conclusion": "This blueprint intends to provide a high level walk through of one possible way of defining a standardized API lifecycle beginning with the manual creation of a Postman collection that describes how an existing API should work. Each element within this blueprint works to provide a simple overview of what is involved across the entire life of an API, with more detail present on the detail page for each element (if you are viewing this on the API lifecycle project site). If you are reading this via a PDF or printed version you can visit the landing page for this blueprint to access more information and view specific actions you might possibly consider taking as part of applying each element of this proposed lifecycle within your own operations. This blueprint is a living document and will continue to evolve and be added to over time based upon feedback from readers. If you have any questions, feedback, or feel like there is more information you need, feel free to jump on the Github discussion for this blueprint, or any of the individual elements present--the value this blueprint provides is actively defined by the feedback community members like you.",
"image": "collection.png",
"tags": ["OpenAPI","Prototype-First"],
"stage": "Existing",
"type": "sync",
"order": 4,
"status": "",
"maturity": "stable",
"version": "2021-09-11",
"areas": [{"label":"Define","image":"images/lifecycle-arrow-define.png","description":"The Postman collection has become a proven solution for defining and troubleshooting existing APIs over the last five years. Providing a machine readable representation of the details of each API request and response that can then be used as an API client, to power documentation and testing. Postman collections provide an ideal foundation for defining what an API can do, then using that collection to power other stops along the API lifecycle, be shared internally via other workspaces, and externally via workspaces, URL, or an embeddable Run in Postman button. Providing an industrial strength approach to laying a foundation for a repeatable and well known API lifecycle for an existing API that is already in production.","elements":[{"name":"Collection","label":"Collection"}]},{"label":"Document","image":"images/lifecycle-arrow-document.png","description":"Having complete, accurate, and easy to follow documentation is essential for all APIs, and is something that  alleviates the number one pain point for API consumers when it comes to onboarding with any API, expanding the number of API paths an application puts to work. Modern approaches to producing API documentation have moved beyond a single static version of documentation simply published to a portal, as well as there being potentially multiple forms of documentation for any single API. Helping API producers onboard consumers easier, reduce the cognitive load when understanding what an API does, and properly define specific business use cases of an API being put to work in an application or as part of an integration.","elements":[{"name":"Reference Documentation","label":"Reference Documentation","context":1}]},{"label":"Test","image":"images/lifecycle-arrow-test.png","description":"A test-driven API lifecycle ensures that each API delivers the intended outcomes it was developed for in the first place, providing manual as well as automated ways to ensure an API hasn't changed unexpectedly and is as performant as required, helping establish a high quality of service consistently across all APIs. API testing should not be an afterthought and should be a default aspect of the API lifecycle for any API being put into production. API testing takes a solid investment in establishing proper testing practices across teams, but once you do the work to establish a baseline of testing, properly train teams on the process and tooling involved, the investment will pay off down the road.","elements":[{"name":"Contract Testing","label":"Contract Testing","context":1},{"name":"Performance Testing","label":"Performance Testing","context":1}]},{"label":"Secure","image":"images/lifecycle-arrow-test.png","description":"Security must be its own area of the API lifecycle, but it is something that should span testing, authentication, and potentially other areas of the API lifecycle. Over the last five years the world of API security has expanded, while also moving further left in the API lifecycle as part of a devops shift in how APIs are delivered. There are a number of elements present when it comes to security, but depending on the overall maturity of API operations the available resources and prioritization available to adequately realize these elements vary.","elements":[{"name":"Authentication","label":"Authentication","context":1},{"name":"Security Testing","label":"Security Testing","context":1}]},{"label":"Monitor","image":"images/lifecycle-arrow-monitor.png","description":"Monitors can be used to execute any Postman collection applied to any environment. Due to the versatility of what a Postman collection can define, collections turn monitors into a powerful API automation and orchestration tool. Beginning with the ability to schedule contract, performance, and other types of tests, but then also allowing for automating specific workflows across many different APIs. Since collections can be used to define anything that can be defined via an API, monitors can be used to schedule the running of each capability from multiple cloud regions, applying many different environmental variables. Making monitors an essential, versatile, and executable part of defining how the API lifecycle works.","elements":[{"name":"Contract Testing Monitor","label":"Contract Testing Monitor","context":1},{"name":"Performance Testing Monitor","label":"Performance Testing Monitor","context":1},{"name":"Security Testing Monitor","label":"Security Testing Monitor","context":1}]},{"label":"Discover","image":"images/lifecycle-arrow-discover.png","description":"The ability to discover APIs at all stages of the API lifecycle is essential for reducing redundancy across operations, helping teams find existing APIs before they develop new ones, properly matching API consumers with the right APIs, while supporting documentation, relevant workflows, and the feedback loops that exist as part of the operation of APIs internally within the enterprise, or externally with 3rd party developers. API discovery does not live at the beginning or the end of the API lifecycle, but should be considered across all areas of the API lifecycle, ensuring that APIs, as well as the operations around them are as discoverable as possible, but well informed when it comes to privacy, security, and terms of service.","elements":[{"name":"Search","label":"Search","context":1},{"name":"Private Network","label":"Private Network","context":1},{"name":"Public Network","label":"Public Network","context":1}]}],
"discussion": "https://github.com/postman-open-technologies/lifecycle/discussions/13",
"yaml": "https://github.com/postman-open-technologies/lifecycle/blob/main/_blueprints/manually-define-collection-for-an-existing-api.md",
"roles": ["Advocate","Architect","Backend","DevOps","Engineering","Frontend","Mobile","Product","Support","Writers"],
"content": "&lt;p&gt;When it comes to defining the API lifecycle for an existing API, sometimes you just need to roll up your sleeves and begin crafting a Postman collection from existing documentation that exists. Adding each individual request, parameters, and other details, while abstracting away authentication details using an environment and variables. Manually defining a collection for an existing API helps establish a cornerstone for an API that is already in production, but could use more investment in documentation, testing, and other areas of a modern API lifecycle. Preparing an API to possibly be iterated upon for a future version, or simply just make sure it is operating and being managed in a well defined away as part of overall API operations. This API blueprint enters the API lifecycle using the proven approach to defining a Postman collection, but then guides you through some of the most comment elements of an API lifecycle that are needed to get an API up to acceptable levels, in alignment with the rest of API operations.&lt;/p&gt;"
}
,

{
"name": "New API Using the AsyncAPI Specification",
"version": "2021-09-11",
"description": "",
"conclusion": "",
"image": "asyncapi.png",
"tags": ["OpenAPI","Design-First"],
"stage": "New",
"type": "async",
"order": 2,
"status": "",
"maturity": "draft",
"version": "2021-09-11",
"areas": [{"label":"Define","image":"images/lifecycle-arrow-define.png","description":"Ensuring that operations supporting an API is properly defined, as well as what is needed to properly design and bring an API to life. A little planning and organization at this step of an APIs journey can go a long way towards ensuring the overall health and velocity of an API, and the applications that depend on this internal, partner, or public API.","elements":[{"name":"Use Cases","label":"Use Cases"},{"name":"Schema","label":"Schema"},{"name":"Events","label":"Events"},{"name":"Application","label":"Application"}]},{"label":"Develop","image":"images/lifecycle-arrow-deploy.png","description":"Provide a mock for the API.","elements":[{"name":"Code","label":"Code"},{"name":"Business Logic","label":"Business Logic"}]},{"label":"Operate","description":"Operate an API in production.","image":"images/lifecycle-arrow-manage.png","elements":[{"name":"Deploy","label":"Deploy"},{"name":"Secure","label":"Secure"},{"name":"Audit","label":"Audit"},{"name":"Monitor","label":"Monitor"},{"name":"Inform","label":"Inform"}]},{"label":"Discover","image":"images/lifecycle-arrow-discover.png","description":"Discovery involving an API.","elements":[{"name":"Events","label":"Events"},{"name":"Relationships","label":"Relationships"}]}],
"discussion": "https://github.com/postman-open-technologies/lifecycle/discussions/19",
"yaml": "https://github.com/postman-open-technologies/lifecycle/blob/main/_blueprints/new-api-using-the-asyncapi-specification.md",
"roles": ["Advocate","Architect","Backend","DevOps","Engineering","Frontend","Mobile","Product","Support","Writers"],
"content": "&lt;p&gt;At vero eos et accusamus et iusto odio dignissimos ducimus qui blanditiis praesentium voluptatum deleniti atque corrupti quos dolores et quas molestias excepturi sint occaecati cupiditate non provident, similique sunt in culpa qui officia deserunt mollitia animi, id est laborum et dolorum fuga. Et harum quidem rerum facilis est et expedita distinctio. Nam libero tempore, cum soluta nobis est eligendi optio cumque nihil impedit quo minus id quod maxime placeat facere possimus, omnis voluptas assumenda est, omnis dolor repellendus. Temporibus autem quibusdam et aut officiis debitis aut rerum necessitatibus saepe eveniet ut et voluptates repudiandae sint et molestiae non recusandae. Itaque earum rerum hic tenetur a sapiente delectus, ut aut reiciendis voluptatibus maiores alias consequatur aut perferendis doloribus asperiores repellat.&lt;/p&gt;"
}
,

{
"name": "New API Using the OpenAPI Specification",
"version": "2021-09-11",
"description": "",
"conclusion": "This blueprint intends to provide a high level walk through of one possible way of defining a standardized API lifecycle which is centered around an API design-first approach to delivering an API with OpenAPI at the center. This view of the API lifecycle will not work for all teams and for all APIs, but it does provide one possible overview that may work for many situations. Each element within this blueprint works to provide a simple overview of what is involved across the entire life of an API, with more detail present on the detail page for each element (if you are viewing this on the API lifecycle project site). If you are reading this via a PDF or printed version you can visit the landing page for this blueprint to access more information and view specific actions you might possibly consider taking as part of applying each element of this proposed lifecycle within your own operations. This blueprint is a living document and will continue to evolve and be added to over time based upon feedback from readers. If you have any questions, feedback, or feel like there is more information you need, feel free to jump on the Github discussion for this blueprint, or any of the individual elements present--the value this blueprint provides is actively defined by the feedback community members like you.",
"image": "openapi.png",
"tags": ["OpenAPI","Design-First"],
"stage": "New",
"type": "sync",
"order": 1,
"status": "",
"maturity": "stable",
"version": "2021-09-11",
"areas": [{"label":"Define","description":"The most important first step of any API lifecycle is to make sure the operations around an API are properly defined, laying the foundation for being able to effectively design and bring an API to life, while also establishing a known place, or places to go to get all the information you need regarding each individual API, or groups of APIs. A little planning and organization at this early step of the API journey can go a long way towards ensuring the overall health and velocity of an API, and the applications and integrations that will depend on each internal, partner, or public API being delivered.","image":"images/lifecycle-arrow-define.png","elements":[{"name":"Team Workspace","label":"Team Workspace","context":1},{"name":"Team Members","label":"Team Members","context":1},{"name":"Github Repository","label":"Github Repository","context":1}]},{"label":"Design","image":"images/lifecycle-arrow-design.png","description":"Having a formal process and approach to designing an API helps establish consistency and the precision of each API that ends up in production, ensuring that APIs are developed using common patterns across an industry, and within an organization, establishing known practices for shaping the surface area and behaviors of APIs that applications are depending upon. API design is something that just doesn’t impact the way an API is used, it is something that impacts almost every stop along the API lifecycle, and will reduce friction and increase velocity throughout the evolution of each API, and the applications and integrations that depend upon them.","elements":[{"name":"OpenAPI","label":"OpenAPI","context":1}]},{"label":"Mock","image":"images/lifecycle-arrow-mock.png","description":"Mocking how an API works and behaves provides an effective way for teams to collaborate, communicate, and iterate as part of the design of an API, but it also is something that can be used as part of testing, or just providing a sandbox environment for API consumers to learn before they actually begin working with any API in production. Effectively mocking an API takes a little time to set up and configure properly, but once available it will help reduce friction across the entire API lifecycle, helping teams more effectively communicate around an API throughout its journey.","elements":[{"name":"Mock Server","label":"Mock Server","context":1},{"name":"Examples","label":"Examples","context":1}]},{"label":"Document","image":"images/lifecycle-arrow-document.png","description":"Having complete, accurate, and easy to follow documentation is essential for all APIs, and is something that  alleviates the number one pain point for API consumers when it comes to onboarding with any API, expanding the number of API paths an application puts to work. Modern approaches to producing API documentation have moved beyond a single static version of documentation simply published to a portal, as well as there being potentially multiple forms of documentation for any single API. Helping API producers onboard consumers easier, reduce the cognitive load when understanding what an API does, and properly define specific business use cases of an API being put to work in an application or as part of an integration.","elements":[{"name":"Reference Documentation","label":"Reference Documentation","context":1}]},{"label":"Deploy","image":"images/lifecycle-arrow-deploy.png","description":"Establishing a well defined process to deploy an API helps teams bring new APIs to life, as well as assists them in more efficiently delivering each future iteration of an API in a consistent and repeatable way. Making sure APIs are deployed using known development, staging, production, and other agreed upon stages that actively apply other elements like documentation, testing, while natively contributing to observability. API deployment practices will likely have been well established as part of an organization’s traditional software development lifecycle, but is something that should be open to defining, standardizing, and making more repeatable and observable as part of the API lifecycle. The API deployment portion of the API lifecycle will be the most difficult for teams to properly define, articulate, and standardize across teams, but it will continue to be one of the most critical areas of the API lifecycle to do this for, otherwise it will be guaranteed to be a repeated source of friction across API operations.","elements":[{"name":"CI/CD Pipeline","label":"CI/CD Pipeline","context":1},{"name":"Gateway","label":"Gateway","context":1}]},{"label":"Manage","image":"images/lifecycle-arrow-manage.png","description":"APIs should always be managed using a set of common, well-defined set of policies that define and govern how APIs are accessed via all stages of the API lifecycle, ensuring that every API has appropriate authentication, rate limits, logging, and other essential requirements of managing APIs at scale, helping strike a balance between making APIs accessible and the privacy and security concerns that exist. As API gateways and management solutions have been commoditized, many of the essential elements like documentation and testing have expanded into their own areas of the API lifecycle, leaving us with a core set of elements that can be applied by teams to help manage how APIs are put to work in applications and as part of system to system integrations.","elements":[{"name":"Onboarding","label":"Onboarding","context":1},{"name":"Usage Plan","label":"Usage Plan","context":1},{"name":"Key","label":"Key","context":1}]},{"label":"Test","image":"images/lifecycle-arrow-test.png","description":"A test-driven API lifecycle ensures that each API delivers the intended outcomes it was developed for in the first place, providing manual as well as automated ways to ensure an API hasn't changed unexpectedly and is as performant as required, helping establish a high quality of service consistently across all APIs. API testing should not be an afterthought and should be a default aspect of the API lifecycle for any API being put into production. API testing takes a solid investment in establishing proper testing practices across teams, but once you do the work to establish a baseline of testing, properly train teams on the process and tooling involved, the investment will pay off down the road.","elements":[{"name":"Contract Testing","label":"Contract Testing","context":1},{"name":"Performance Testing","label":"Performance Testing","context":1}]},{"label":"Secure","image":"images/lifecycle-arrow-test.png","description":"Security must be its own area of the API lifecycle, but it is something that should span testing, authentication, and potentially other areas of the API lifecycle. Over the last five years the world of API security has expanded, while also moving further left in the API lifecycle as part of a devops shift in how APIs are delivered. There are a number of elements present when it comes to security, but depending on the overall maturity of API operations the available resources and prioritization available to adequately realize these elements vary.","elements":[{"name":"Authentication","label":"Authentication","context":1},{"name":"Security Testing","label":"Security Testing","context":1}]},{"label":"Monitor","image":"images/lifecycle-arrow-monitor.png","description":"Monitors can be used to execute any Postman collection applied to any environment. Due to the versatility of what a Postman collection can define, collections turn monitors into a powerful API automation and orchestration tool. Beginning with the ability to schedule contract, performance, and other types of tests, but then also allowing for automating specific workflows across many different APIs. Since collections can be used to define anything that can be defined via an API, monitors can be used to schedule the running of each capability from multiple cloud regions, applying many different environmental variables. Making monitors an essential, versatile, and executable part of defining how the API lifecycle works.","elements":[{"name":"Contract Testing Monitor","label":"Contract Testing Monitor","context":1},{"name":"Performance Testing Monitor","label":"Performance Testing Monitor","context":1},{"name":"Security Testing Monitor","label":"Security Testing Monitor","context":1}]},{"label":"Discover","image":"images/lifecycle-arrow-discover.png","description":"The ability to discover APIs at all stages of the API lifecycle is essential for reducing redundancy across operations, helping teams find existing APIs before they develop new ones, properly matching API consumers with the right APIs, while supporting documentation, relevant workflows, and the feedback loops that exist as part of the operation of APIs internally within the enterprise, or externally with 3rd party developers. API discovery does not live at the beginning or the end of the API lifecycle, but should be considered across all areas of the API lifecycle, ensuring that APIs, as well as the operations around them are as discoverable as possible, but well informed when it comes to privacy, security, and terms of service.","elements":[{"name":"Search","label":"Search","context":1},{"name":"Private Network","label":"Private Network","context":1},{"name":"Public Network","label":"Public Network","context":1}]},{"label":"End of Life","image":"images/lifecycle-arrow-retire.png","description":"Having a plan for the eventual retirement and ultimate deprecation of an API, or for specific paths or versions of an API should be a part of every API lifecycle, and even when there is no plan for deprecation there should be a process in place for setting consumer expectations for how long an API will be supported, as well as formal process to follow once retirement comes into view on the horizon. Planning for the end of life of each API will be commonplace, but only becomes a problem when there is no plan, or no communication with consumers.","elements":[{"name":"Retire","label":"Retire","context":1},{"name":"Deprecate","label":"Deprecate","context":1}]}],
"discussion": "https://github.com/postman-open-technologies/lifecycle/discussions/9",
"yaml": "https://github.com/postman-open-technologies/lifecycle/blob/main/_blueprints/new-api-using-the-openapi-specification.md",
"roles": ["Advocate","Architect","Backend","DevOps","Engineering","Frontend","Mobile","Product","Support","Writers"],
"content": "&lt;p&gt;This API lifecycle blueprint introduces the API lifecycle in what is widely considered to be an API design-first way, ensuring that each API is adequately defined by and leveraging the OpenAPI specification to design, mock, document, and iterate upon the design of each API before actually writing any code, or publishing an API to a gateway. This approach is widely considered to be desirable because it allows for API producers and even consumer stakeholders to be more closely involved in what an API will do as early on in the process as possible. This blueprint looks to provide you with a walk through of one of the more optimal and forward leaning approaches for establishing a standardized API lifecycle across your teams, helping ensure that the API lifecycle is driven by machine readable artifacts, and possesses clear steps for moving API artifacts from design to production in a way that everyone can understand while incentivizing collaboration at each stop along the way.&lt;/p&gt;"
}
,

{
"name": "Observability",
"version": "2021-11-24",
"description": "",
"conclusion": "Text",
"image": "workflow.png",
"tags": ["Observability"],
"stage": "Automation",
"type": "sync",
"order": 1,
"status": "draft",
"maturity": "optimized",
"version": "2021-11-24",
"areas": [{"label":"Teams","description":"Text","image":"images/lifecycle-arrow-define.png","elements":[{"name":"Members","label":"Members"},{"name":"Groups","label":"Groups"},{"name":"RBAC","label":"RBAC"}]},{"label":"Workspaces","description":"Text","image":"images/lifecycle-arrow-define.png","elements":[{"name":"Watches","label":"Watches"},{"name":"History","label":"History"},{"name":"Activities","label":"Activities"}]},{"label":"APIs","description":"Text","image":"images/lifecycle-arrow-define.png","elements":[{"name":"Watching","label":"Watching"},{"name":"Changes","label":"Changes"},{"name":"Comments","label":"Comments"}]},{"label":"Lifecycle","description":"Text","image":"images/lifecycle-arrow-define.png","elements":[{"name":"Discover","label":"Discover"},{"name":"Define","label":"Define"},{"name":"Design","label":"Design"},{"name":"Develop","label":"Develop"},{"name":"Deploy","label":"Deploy"},{"name":"Observe","label":"Observe"}]},{"label":"Reporting","description":"Text","image":"images/lifecycle-arrow-define.png","elements":[{"name":"Teams","label":"Teams"},{"name":"APIs","label":"APIs"},{"name":"Security","label":"Security"}]},{"label":"Integrations","description":"Text","image":"images/lifecycle-arrow-define.png","elements":[{"name":"Source Control","label":"Source Control"},{"name":"CI/CD","label":"CI/CD"},{"name":"Gateway","label":"Gateway"},{"name":"APM","label":"APM"}]}],
"discussion": "",
"yaml": "",
"roles": ["Advocate"],
"content": ""
}
,

{
"name": "Onboarding Collection",
"version": "2021-11-24",
"description": "",
"conclusion": "Text",
"image": "workflow.png",
"tags": ["Requests"],
"stage": "Automation",
"type": "sync",
"order": 1,
"status": "draft",
"maturity": "optimized",
"version": "2021-11-24",
"areas": [{"label":"Purpose","description":"Text","image":"images/lifecycle-arrow-define.png","elements":[{"name":"First Impression","label":"First Impression"},{"name":"Cognitive Load","label":"Cognitive Load"},{"name":"Time to First Call","label":"Time to First Call"},{"name":"Engagement","label":"Engagement"}]},{"label":"Structure","description":"Text","image":"images/lifecycle-arrow-define.png","elements":[{"name":"Authorization","label":"Authorization"},{"name":"Folders","label":"Folders"},{"name":"Requests","label":"Requests"},{"name":"Examples","label":"Examples"}]},{"label":"Environment","description":"Text","image":"images/lifecycle-arrow-define.png","elements":[{"name":"Stages","label":"Stages"},{"name":"Variables","label":"Variables"},{"name":"Authorization Variables","label":"Authorization Variables"}]},{"label":"Engagement","description":"Text","image":"images/lifecycle-arrow-define.png","elements":[{"name":"Collection URL","label":"Collection URL"},{"name":"Collection Button","label":"Collection Button"},{"name":"Collection Watch","label":"Collection Watch"},{"name":"Collection Fork","label":"Collection Fork"},{"name":"Collection Pull Request","label":"Collection Pull Request"},{"name":"Collection Merge","label":"Collection Merge"}]}],
"discussion": "",
"yaml": "",
"roles": ["Advocate","Architect","CIO","CISO","CTO","Engineering","Product"],
"content": ""
}
,

{
"name": "OpenAPI",
"version": "2021-11-24",
"description": "",
"conclusion": "Text",
"image": "workflow.png",
"tags": ["Requests"],
"stage": "Automation",
"type": "sync",
"order": 1,
"status": "draft",
"maturity": "optimized",
"version": "2021-11-24",
"areas": [{"label":"Purpose","description":"Text","image":"images/lifecycle-arrow-define.png","elements":[{"name":"Machine-Readable Artifact","label":"Machine-Readable Artifact"},{"name":"Human-Readable Artifact","label":"Human-Readable Artifact"},{"name":"Lifecycle","label":"Lifecycle"}]},{"label":"Objects","description":"Text","image":"images/lifecycle-arrow-define.png","elements":[{"name":"Info","label":"Info"},{"name":"Contact","label":"Contact"},{"name":"License","label":"License"},{"name":"Servers","label":"Servers"},{"name":"Components","label":"Components"},{"name":"Paths","label":"Paths"},{"name":"Operations","label":"Operations"},{"name":"Request Bodies","label":"Request Bodies"},{"name":"Responses","label":"Responses"},{"name":"Examples","label":"Examples"},{"name":"Schema","label":"Schema"}]},{"label":"Usage","description":"Text","image":"images/lifecycle-arrow-define.png","elements":[{"name":"Documentation","label":"Documentation"},{"name":"Mock Servers","label":"Mock Servers"},{"name":"Tests","label":"Tests"},{"name":"Security","label":"Security"}]}],
"discussion": "",
"yaml": "",
"roles": ["Advocate","Architect","CIO","CISO","CTO","Engineering","Product"],
"content": ""
}
,

{
"name": "Production",
"version": "2021-11-24",
"description": "",
"conclusion": "Text",
"image": "workflow.png",
"tags": ["Storytelling","Production"],
"stage": "Engage",
"type": "sync",
"order": 1,
"status": "draft",
"maturity": "optimized",
"version": "2021-11-24",
"areas": [{"label":"Components","description":"Text","image":"images/lifecycle-arrow-define.png","elements":[{"name":"Blog Post","label":"Blog Post"},{"name":"Video","label":"Video"},{"name":"Tweet","label":"Tweet"},{"name":"Workspace","label":"Workspace"},{"name":"Collection","label":"Collection"}]},{"label":"Metrics","description":"Text","image":"images/lifecycle-arrow-define.png","elements":[{"name":"Blog Page Views","label":"Blog Page Views"},{"name":"Video Views","label":"Video Views"},{"name":"Tweet Likes","label":"Tweet Likes"},{"name":"Retweets","label":"Retweets"},{"name":"Workspace Watches","label":"Workspace Watches"},{"name":"Collection Watches","label":"Collection Watches"},{"name":"Collection Forks","label":"Collection Forks"}]}],
"discussion": "",
"yaml": "",
"roles": ["Advocate"],
"content": ""
}
,

{
"name": "Productivity",
"version": "2021-11-24",
"description": "",
"conclusion": "Text",
"image": "workflow.png",
"tags": ["Requests"],
"stage": "Automation",
"type": "sync",
"order": 1,
"status": "draft",
"maturity": "optimized",
"version": "2021-11-24",
"areas": [{"label":"Landscape","description":"Text","image":"images/lifecycle-arrow-define.png","elements":[{"name":"Teams","label":"Teams"},{"name":"Workspaces","label":"Workspaces"},{"name":"APIs","label":"APIs"}]},{"label":"Landscape","description":"Text","image":"images/lifecycle-arrow-define.png","elements":[{"name":"Discover","label":"Discover"},{"name":"Define","label":"Define"},{"name":"Design","label":"Design"},{"name":"Develop","label":"Develop"},{"name":"Deploy","label":"Deploy"},{"name":"Observe","label":"Observe"}]},{"label":"Design-First","description":"Text","image":"images/lifecycle-arrow-define.png","elements":[{"name":"OpenAPI","label":"OpenAPI"},{"name":"Mock Servers","label":"Mock Servers"},{"name":"Documentation","label":"Documentation"},{"name":"Testing","label":"Testing"}]},{"label":"Collaboration","description":"Text","image":"images/lifecycle-arrow-define.png","elements":[{"name":"Watching","label":"Watching"},{"name":"Comments","label":"Comments"},{"name":"Notifications","label":"Notifications"},{"name":"Sharing","label":"Sharing"},{"name":"Forking","label":"Forking"}]}],
"discussion": "",
"yaml": "",
"roles": ["Advocate"],
"content": ""
}
,

{
"name": "Prototype a New API Using a Postman Collection",
"version": "2021-09-11",
"description": "",
"conclusion": "This blueprint intends to provide a high level walk through of one possible way of defining a standardized API lifecycle which is centered around an API design-first approach to delivering an API with Postman collections at the center. This view of the API lifecycle will not work for all teams and for all APIs, but it does provide one possible overview that may work for many situations. Each element within this blueprint works to provide a simple overview of what is involved across the entire life of an API, with more detail present on the detail page for each element (if you are viewing this on the API lifecycle project site). If you are reading this via a PDF or printed version you can visit the landing page for this blueprint to access more information and view specific actions you might possibly consider taking as part of applying each element of this proposed lifecycle within your own operations. This blueprint is a living document and will continue to evolve and be added to over time based upon feedback from readers. If you have any questions, feedback, or feel like there is more information you need, feel free to jump on the Github discussion for this blueprint, or any of the individual elements present--the value this blueprint provides is actively defined by the feedback community members like you.",
"image": "collection.png",
"tags": ["OpenAPI","Prototype-First"],
"stage": "New",
"type": "sync",
"order": 3,
"status": "",
"maturity": "stable",
"version": "2021-09-11",
"areas": [{"label":"Define","description":"The most important first step of any API lifecycle is to make sure the operations around an API are properly defined, laying the foundation for being able to effectively design and bring an API to life, while also establishing a known place, or places to go to get all the information you need regarding each individual API, or groups of APIs. A little planning and organization at this early step of the API journey can go a long way towards ensuring the overall health and velocity of an API, and the applications and integrations that will depend on each internal, partner, or public API being delivered.","image":"images/lifecycle-arrow-define.png","elements":[{"name":"Team Workspace","label":"Team Workspace","context":1},{"name":"Team Members","label":"Team Members","context":1}]},{"label":"Design","image":"images/lifecycle-arrow-design.png","description":"Having a formal process and approach to designing an API helps establish consistency and the precision of APIs in production, ensuring that APIs are developed using common patterns across an industry, and within an organization, establishing known practices for shaping the surface area and behaviors of APIs that applications are depending upon. But instead of using OpenAPI as the catalyst for the API design process, a Postman collection is used to prototype the API, and then you can generate the OpenAPI from the collection when you are ready to move to production, or at least a more stable portion of the API design phase.","elements":[{"name":"Prototype Collection","label":"Prototype Collection"},{"name":"OpenAPI","label":"OpenAPI"}]},{"label":"Mock","image":"images/lifecycle-arrow-mock.png","description":"Mocking how an API works and behaves provides an effective way for teams to collaborate, communicate, and iterate as part of the design of an API, but it also is something that can be used as part of testing, or just providing a sandbox environment for API consumers to learn before they actually begin working with any API in production. Effectively mocking an API takes a little time to set up and configure properly, but once available it will help reduce friction across the entire API lifecycle, helping teams more effectively communicate around an API throughout its journey.","elements":[{"name":"Mock Server","label":"Mock Server","context":1},{"name":"Examples","label":"Examples","context":1}]},{"label":"Document","image":"images/lifecycle-arrow-document.png","description":"Having complete, accurate, and easy to follow documentation is essential for all APIs, and is something that  alleviates the number one pain point for API consumers when it comes to onboarding with any API, expanding the number of API paths an application puts to work. Modern approaches to producing API documentation have moved beyond a single static version of documentation simply published to a portal, as well as there being potentially multiple forms of documentation for any single API. Helping API producers onboard consumers easier, reduce the cognitive load when understanding what an API does, and properly define specific business use cases of an API being put to work in an application or as part of an integration.","elements":[{"name":"Reference Documentation","label":"Reference Documentation","context":1}]},{"label":"Deploy","image":"images/lifecycle-arrow-deploy.png","description":"Establishing a well defined process to deploy an API helps teams bring new APIs to life, as well as assists them in more efficiently delivering each future iteration of an API in a consistent and repeatable way. Making sure APIs are deployed using known development, staging, production, and other agreed upon stages that actively apply other elements like documentation, testing, while natively contributing to observability. API deployment practices will likely have been well established as part of an organization’s traditional software development lifecycle, but is something that should be open to defining, standardizing, and making more repeatable and observable as part of the API lifecycle. The API deployment portion of the API lifecycle will be the most difficult for teams to properly define, articulate, and standardize across teams, but it will continue to be one of the most critical areas of the API lifecycle to do this for, otherwise it will be guaranteed to be a repeated source of friction across API operations.","elements":[{"name":"CI/CD Pipeline","label":"CI/CD Pipeline","context":1},{"name":"Gateway","label":"Gateway","context":1}]},{"label":"Manage","image":"images/lifecycle-arrow-manage.png","description":"APIs should always be managed using a set of common, well-defined set of policies that define and govern how APIs are accessed via all stages of the API lifecycle, ensuring that every API has appropriate authentication, rate limits, logging, and other essential requirements of managing APIs at scale, helping strike a balance between making APIs accessible and the privacy and security concerns that exist. As API gateways and management solutions have been commoditized, many of the essential elements like documentation and testing have expanded into their own areas of the API lifecycle, leaving us with a core set of elements that can be applied by teams to help manage how APIs are put to work in applications and as part of system to system integrations.","elements":[{"name":"Onboarding","label":"Onboarding","context":1},{"name":"Usage Plan","label":"Usage Plan","context":1},{"name":"Key","label":"Key","context":1}]},{"label":"Test","image":"images/lifecycle-arrow-test.png","description":"A test-driven API lifecycle ensures that each API delivers the intended outcomes it was developed for in the first place, providing manual as well as automated ways to ensure an API hasn't changed unexpectedly and is as performant as required, helping establish a high quality of service consistently across all APIs. API testing should not be an afterthought and should be a default aspect of the API lifecycle for any API being put into production. API testing takes a solid investment in establishing proper testing practices across teams, but once you do the work to establish a baseline of testing, properly train teams on the process and tooling involved, the investment will pay off down the road.","elements":[{"name":"Contract Testing","label":"Contract Testing","context":1},{"name":"Performance Testing","label":"Performance Testing","context":1}]},{"label":"Secure","image":"images/lifecycle-arrow-test.png","description":"Security must be its own area of the API lifecycle, but it is something that should span testing, authentication, and potentially other areas of the API lifecycle. Over the last five years the world of API security has expanded, while also moving further left in the API lifecycle as part of a devops shift in how APIs are delivered. There are a number of elements present when it comes to security, but depending on the overall maturity of API operations the available resources and prioritization available to adequately realize these elements vary.","elements":[{"name":"Authentication","label":"Authentication","context":1},{"name":"Security Testing","label":"Security Testing","context":1}]},{"label":"Monitor","image":"images/lifecycle-arrow-monitor.png","description":"Monitors can be used to execute any Postman collection applied to any environment. Due to the versatility of what a Postman collection can define, collections turn monitors into a powerful API automation and orchestration tool. Beginning with the ability to schedule contract, performance, and other types of tests, but then also allowing for automating specific workflows across many different APIs. Since collections can be used to define anything that can be defined via an API, monitors can be used to schedule the running of each capability from multiple cloud regions, applying many different environmental variables. Making monitors an essential, versatile, and executable part of defining how the API lifecycle works.","elements":[{"name":"Contract Testing Monitor","label":"Contract Testing Monitor","context":1},{"name":"Performance Testing Monitor","label":"Performance Testing Monitor","context":1},{"name":"Security Testing Monitor","label":"Security Testing Monitor","context":1}]},{"label":"Discover","image":"images/lifecycle-arrow-discover.png","description":"The ability to discover APIs at all stages of the API lifecycle is essential for reducing redundancy across operations, helping teams find existing APIs before they develop new ones, properly matching API consumers with the right APIs, while supporting documentation, relevant workflows, and the feedback loops that exist as part of the operation of APIs internally within the enterprise, or externally with 3rd party developers. API discovery does not live at the beginning or the end of the API lifecycle, but should be considered across all areas of the API lifecycle, ensuring that APIs, as well as the operations around them are as discoverable as possible, but well informed when it comes to privacy, security, and terms of service.","elements":[{"name":"Search","label":"Search","context":1},{"name":"Private Network","label":"Private Network","context":1},{"name":"Public Network","label":"Public Network","context":1}]},{"label":"End of Life","image":"images/lifecycle-arrow-retire.png","description":"Having a plan for the eventual retirement and ultimate deprecation of an API, or for specific paths or versions of an API should be a part of every API lifecycle, and even when there is no plan for deprecation there should be a process in place for setting consumer expectations for how long an API will be supported, as well as formal process to follow once retirement comes into view on the horizon. Planning for the end of life of each API will be commonplace, but only becomes a problem when there is no plan, or no communication with consumers.","elements":[{"name":"Retire","label":"Retire","context":1},{"name":"Deprecate","label":"Deprecate","context":1}]}],
"discussion": "https://github.com/postman-open-technologies/lifecycle/discussions/16",
"yaml": "https://github.com/postman-open-technologies/lifecycle/blob/main/_blueprints/prototype-a-new-api-using-collection.md",
"roles": ["Advocate","Architect","Backend","DevOps","Engineering","Frontend","Mobile","Product","Support","Writers"],
"content": "&lt;p&gt;Postman collections make it really easy to define the structure of an API, using requests to describe the paths, parameters, bodies, and headers, while using examples to demonstrate what will be returned with each response. When you combine collections with the ability to generate mock servers, and the built-in documentation that comes with each collection, you end up with a pretty robust way to prototype APIs. Allowing teams to collaboratively prototype what an API should do, demonstrating functionality, and documentation resources and capabilities along the way, rapdily defining what an API will do in production–without writing code, or hand-crafting an OpenAPI definition. Some teams will find this approach to delivering APIs much more desirable than hand-crafting an OpenAPI and generating mock servers and documentation from the OpenAPI, providing yet another way to approach a modern API lifecycle.&lt;/p&gt;"
}
,

{
"name": "Public Teams",
"version": "2021-11-24",
"description": "",
"conclusion": "Text",
"image": "workflow.png",
"tags": ["Requests"],
"stage": "Automation",
"type": "sync",
"order": 1,
"status": "draft",
"maturity": "optimized",
"version": "2021-11-24",
"areas": [{"label":"Team Profile","description":"Text","image":"images/lifecycle-arrow-define.png","elements":[{"name":"Team Name","label":"Team Name"},{"name":"Team Favicon","label":"Team Favicon"},{"name":"Team Logo","label":"Team Logo"},{"name":"Team Cover Photo","label":"Team Cover Photo"},{"name":"Team Public URL","label":"Team Public URL"},{"name":"Team About","label":"Team Public"},{"name":"Team Website","label":"Team Website"},{"name":"Team Twitter","label":"Team Twitter"},{"name":"Team Github","label":"Team Github"}]},{"label":"Team Member Profile","description":"Text","image":"images/lifecycle-arrow-define.png","elements":[{"name":"Team Member Name","label":"Team Member Name"},{"name":"Team Member Username","label":"Team Member Username"},{"name":"Team Member Photo","label":"Team Member Photo"},{"name":"Team Member Cover Photo","label":"Team Member Cover Photo"},{"name":"Team Member About","label":"Team Member Public"},{"name":"Team Member Website","label":"Team Member Website"},{"name":"Team Member Twitter","label":"Team Member Twitter"},{"name":"Team Member Github","label":"Team Member Github"}]},{"label":"Public Profile","description":"Text","image":"images/lifecycle-arrow-define.png","elements":[{"name":"Public Profile Appearance","label":"Public Profile Appearance"},{"name":"Public Profile Completeness","label":"Public Profile Completeness"},{"name":"Public Profile Overview","label":"Public Profile Overview"},{"name":"Public Profile Collections","label":"Public Profile Collections"},{"name":"Public Profile APIs","label":"Public Profile APIs"},{"name":"Public Profile Workspaces","label":"Public Profile Workspaces"},{"name":"Public Profile Team Members","label":"Public Profile Members"}]}],
"discussion": "",
"yaml": "",
"roles": ["Advocate","Architect","CIO","CISO","CTO","Engineering","Product"],
"content": ""
}
,

{
"name": "Public Workspaces",
"version": "2021-11-24",
"description": "",
"conclusion": "Text",
"image": "workflow.png",
"tags": ["Requests"],
"stage": "Automation",
"type": "sync",
"order": 1,
"status": "draft",
"maturity": "optimized",
"version": "2021-11-24",
"areas": [{"label":"Contents","description":"Text","image":"images/lifecycle-arrow-define.png","elements":[{"name":"Collections","label":"Collections"},{"name":"APIs","label":"APIs"},{"name":"Environments","label":"Environments"},{"name":"Monitors","label":"Monitors"}]},{"label":"Engagement","description":"Text","image":"images/lifecycle-arrow-define.png","elements":[{"name":"Contributors","label":"Contributors"},{"name":"Comments","label":"Comments"},{"name":"Watches","label":"Watches"},{"name":"Forks","label":"Forks"}]}],
"discussion": "",
"yaml": "",
"roles": ["Advocate","Architect","CIO","CISO","CTO","Engineering","Product"],
"content": ""
}
,

{
"name": "Quality",
"version": "2021-11-24",
"description": "",
"conclusion": "Text",
"image": "workflow.png",
"tags": ["Requests"],
"stage": "Automation",
"type": "sync",
"order": 1,
"status": "draft",
"maturity": "optimized",
"version": "2021-11-24",
"areas": [{"label":"Contracts","description":"Text","image":"images/lifecycle-arrow-define.png","elements":[{"name":"Tests","label":"Tests"},{"name":"Monitors","label":"Monitors"},{"name":"Pipelines","label":"Pipelines"},{"name":"Results","label":"Results"}]},{"label":"Performance","description":"Text","image":"images/lifecycle-arrow-define.png","elements":[{"name":"Tests","label":"Tests"},{"name":"Monitors","label":"Monitors"},{"name":"Pipelines","label":"Pipelines"},{"name":"Results","label":"Results"}]},{"label":"Security","description":"Text","image":"images/lifecycle-arrow-define.png","elements":[{"name":"Tests","label":"Tests"},{"name":"Monitors","label":"Monitors"},{"name":"Pipelines","label":"Pipelines"},{"name":"Results","label":"Results"}]},{"label":"Governance","description":"Text","image":"images/lifecycle-arrow-define.png","elements":[{"name":"Design","label":"Design"},{"name":"Documentation","label":"Documentation"},{"name":"Testing","label":"Testing"},{"name":"Security","label":"Security"},{"name":"Monitoring","label":"Monitoring"}]},{"label":"Observability","description":"Text","image":"images/lifecycle-arrow-define.png","elements":[{"name":"Reporting","label":"Reporting"},{"name":"APM","label":"APM"}]}],
"discussion": "",
"yaml": "",
"roles": ["Advocate"],
"content": ""
}
,

{
"name": "Reference Collection",
"version": "2021-11-24",
"description": "",
"conclusion": "Text",
"image": "workflow.png",
"tags": ["Requests"],
"stage": "Automation",
"type": "sync",
"order": 1,
"status": "draft",
"maturity": "optimized",
"version": "2021-11-24",
"areas": [{"label":"Purpose","description":"Text","image":"images/lifecycle-arrow-define.png","elements":[{"name":"Documentation","label":"Documentation"},{"name":"Reference","label":"Reference"},{"name":"Source","label":"Source"},{"name":"Engagement","label":"Engagement"}]},{"label":"Structure","description":"Text","image":"images/lifecycle-arrow-define.png","elements":[{"name":"Authorization","label":"Authorization"},{"name":"Folders","label":"Folders"},{"name":"Requests","label":"Requests"},{"name":"Examples","label":"Examples"}]},{"label":"Environment","description":"Text","image":"images/lifecycle-arrow-define.png","elements":[{"name":"Stages","label":"Stages"},{"name":"Variables","label":"Variables"},{"name":"Authorization Variables","label":"Authorization Variables"}]},{"label":"Engagement","description":"Text","image":"images/lifecycle-arrow-define.png","elements":[{"name":"Collection URL","label":"Collection URL"},{"name":"Collection Button","label":"Collection Button"},{"name":"Collection Watch","label":"Collection Watch"},{"name":"Collection Fork","label":"Collection Fork"},{"name":"Collection Pull Request","label":"Collection Pull Request"},{"name":"Collection Merge","label":"Collection Merge"}]}],
"discussion": "",
"yaml": "",
"roles": ["Advocate","Architect","CIO","CISO","CTO","Engineering","Product"],
"content": ""
}
,

{
"name": "Regulation",
"version": "2021-11-24",
"description": "",
"conclusion": "Text",
"image": "workflow.png",
"tags": ["Requests"],
"stage": "Automation",
"type": "sync",
"order": 1,
"status": "draft",
"maturity": "optimized",
"version": "2021-11-24",
"areas": [{"label":"Operations","description":"Text","image":"images/lifecycle-arrow-define.png","elements":[{"name":"Discovery","label":"Discovery"},{"name":"Governance","label":"Governance"},{"name":"Observability","label":"Observability"}]},{"label":"Compliance","description":"Text","image":"images/lifecycle-arrow-define.png","elements":[{"name":"Rules","label":"Rules"},{"name":"Reporting","label":"Reporting"}]}],
"discussion": "",
"yaml": "",
"roles": ["Advocate"],
"content": ""
}
,

{
"name": "Requests",
"version": "2021-11-24",
"description": "",
"conclusion": "Text",
"image": "workflow.png",
"tags": ["Requests"],
"stage": "Automation",
"type": "sync",
"order": 1,
"status": "draft",
"maturity": "optimized",
"version": "2021-11-24",
"areas": [{"label":"Requests","description":"Text","image":"images/lifecycle-arrow-define.png","elements":[{"name":"HTTP Methods","label":"HTTP Methods"},{"name":"URL","label":"URL"},{"name":"Query Parameters","label":"Query Parameters"},{"name":"Authorization","label":"Authorization"},{"name":"Request Headers","label":"Request Headers"},{"name":"Request Body","label":"Request Body"},{"name":"Request Settings","label":"Request Settings"}]},{"label":"Response","description":"Text","image":"images/lifecycle-arrow-define.png","elements":[{"name":"Response Body","label":"Response Body"},{"name":"Cookies","label":"Cookies"},{"name":"Response Headers","label":"Response Headers"},{"name":"Visualizer","label":"Visualizer"},{"name":"Response Network","label":"Response Network"},{"name":"Response Time","label":"Response Time"}]}],
"discussion": "",
"yaml": "",
"roles": ["Backend","Data","DevOps","Engineering","Frontend","Mobile","Product","Security","Writers"],
"content": ""
}
,

{
"name": "Security",
"version": "2021-11-24",
"description": "",
"conclusion": "Text",
"image": "workflow.png",
"tags": ["Requests"],
"stage": "Automation",
"type": "sync",
"order": 1,
"status": "draft",
"maturity": "optimized",
"version": "2021-11-24",
"areas": [{"label":"Folders","description":"Text","image":"images/lifecycle-arrow-define.png","elements":[{"name":"Pre-Request Scripts","label":"Pre-Request Scripts"},{"name":"Test Scripts","label":"Test Scripts"}]},{"label":"Requests","description":"Text","image":"images/lifecycle-arrow-define.png","elements":[{"name":"Pre-Request Scripts","label":"Pre-Request Scripts"},{"name":"Test Scripts","label":"Test Scripts"}]},{"label":"Response","description":"Text","image":"images/lifecycle-arrow-define.png","elements":[{"name":"Test Results","label":"Test Results"}]},{"label":"Automation","description":"Text","image":"images/lifecycle-arrow-define.png","elements":[{"name":"Monitors","label":"Monitors"},{"name":"Pipelines","label":"Pipelines"}]},{"label":"Observability","description":"Text","image":"images/lifecycle-arrow-define.png","elements":[{"name":"Reporting","label":"Reporting"},{"name":"APM","label":"APM"}]}],
"discussion": "",
"yaml": "",
"roles": ["Advocate"],
"content": ""
}
,

{
"name": "Standards",
"version": "2021-11-24",
"description": "",
"conclusion": "Text",
"image": "workflow.png",
"tags": ["Requests"],
"stage": "Automation",
"type": "sync",
"order": 1,
"status": "draft",
"maturity": "optimized",
"version": "2021-11-24",
"areas": [{"label":"Internet","description":"Text","image":"images/lifecycle-arrow-define.png","elements":[{"name":"IANA","label":"IANA"},{"name":"RFCs","label":"RFCs"}]},{"label":"Industry","description":"Text","image":"images/lifecycle-arrow-define.png","elements":[{"name":"PSD2","label":"PSD2"},{"name":"FHIR","label":"FHIR"}]},{"label":"Industry","description":"Text","image":"images/lifecycle-arrow-define.png","elements":[{"name":"Pagination","label":"Pagination"},{"name":"Headers","label":"Headers"}]}],
"discussion": "",
"yaml": "",
"roles": ["Advocate"],
"content": ""
}
,

{
"name": "Strategy",
"version": "2021-11-24",
"description": "",
"conclusion": "Text",
"image": "workflow.png",
"tags": ["Requests"],
"stage": "Automation",
"type": "sync",
"order": 1,
"status": "draft",
"maturity": "optimized",
"version": "2021-11-24",
"areas": [{"label":"Organization","description":"Text","image":"images/lifecycle-arrow-define.png","elements":[{"name":"Domains","label":"Domains"},{"name":"Groups","label":"Groups"},{"name":"Teams","label":"Teams"}]},{"label":"Governance","description":"Text","image":"images/lifecycle-arrow-define.png","elements":[{"name":"Workspace","label":"Workspace"},{"name":"Design","label":"Design"},{"name":"Documentation","label":"Documentation"},{"name":"Management","label":"Management"},{"name":"Testing","label":"Testing"},{"name":"Security","label":"Security"}]},{"label":"Standards","description":"Text","image":"images/lifecycle-arrow-define.png","elements":[{"name":"Internet","label":"Internet"},{"name":"Industry","label":"Industry"},{"name":"Organization","label":"Organization"}]}],
"discussion": "",
"yaml": "",
"roles": ["Advocate"],
"content": ""
}
,

{
"name": "Test Automation",
"version": "2021-09-11",
"description": "",
"conclusion": "This blueprint is meant to provide a standardized approach to automating the testing of APIs across operations as part of a standardized API lifecycle. Each element within this blueprint works to provide a simple overview of what is involved across the entire life of an API, with more detail present on the detail page for each element (if you are viewing this on the API lifecycle project site). If you are reading this via a PDF or printed version you can visit the landing page for this blueprint to access more information and view specific actions you might possibly consider taking as part of applying each element of this proposed lifecycle within your own operations. This blueprint is a living document and will continue to evolve and be added to over time based upon feedback from readers. If you have any questions, feedback, or feel like there is more information you need, feel free to jump on the Github discussion for this blueprint, or any of the individual elements present--the value this blueprint provides is actively defined by the feedback community members like you.",
"image": "test-automation.png",
"tags": ["OpenAPI","Design-First"],
"stage": "Automation",
"type": "sync",
"order": 1,
"status": "",
"maturity": "stable",
"version": "2021-09-11",
"areas": [{"label":"Define","description":"The most important first step of any API lifecycle is to make sure the operations around an API are properly defined, laying the foundation for being able to effectively design and bring an API to life, while also establishing a known place, or places to go to get all the information you need regarding each individual API, or groups of APIs. A little planning and organization at this early step of the API journey can go a long way towards ensuring the overall health and velocity of an API, and the applications and integrations that will depend on each internal, partner, or public API being delivered.","image":"images/lifecycle-arrow-define.png","elements":[{"name":"Team Workspace","label":"Team Workspace","context":1},{"name":"Team Members","label":"Team Members","context":1},{"name":"Github Repository","label":"Github Repository","context":1},{"name":"OpenAPI","label":"OpenAPI","context":1}]},{"label":"Test","image":"images/lifecycle-arrow-test.png","description":"A test-driven API lifecycle ensures that each API accomplishes the intended purpose it was developed for, providing manual and automated ways to ensure an API hasn't changed unexpectedly, is as performant as required, and meets the security expectations of everyone involved, helping establish a high quality of service consistently across all APIs.","elements":[{"name":"Contract Testing","label":"Contract Testing"}]},{"label":"Monitor","image":"images/lifecycle-arrow-monitor.png","description":"All tests applied to an API should be monitored on a logical schedule and from relevant geographic regions, monitoring that APIs aren't breaking their contract, falling below their agreed upon service level agreement (SLA), or becoming a security risk, helping automate the quality of service across APIs in a way that allows teams to be as productive as possible.","elements":[{"name":"Monitor","label":"Monitor"},{"name":"Contract Testing Monitor","label":"Contract Testing Monitor"},{"name":"Contract Testing Results","label":"Contract Testing Results"}]},{"label":"Build","image":"images/lifecycle-arrow-deploy.png","description":"Tests can be automated using a CI/CD pipeline, allowing for test to be executed every time a commit or pull request is made against a repo. Allowing tests to be run against any instance of an API, ensuring that any API being deployed has not broken it's contract, and the API does what is expected.","elements":[{"name":"CI/CD Pipeline","label":"CI/CD Pipeline","context":1},{"name":"Newman","label":"Newman","context":1},{"name":"Development Environments","label":"Development Environments"},{"name":"Production Environments","label":"Production Environments"},{"name":"Contract Testing","label":"Contract Testing"},{"name":"Contract Testing Results","label":"Contract Testing Results"}]},{"label":"Observability","image":"images/lifecycle-arrow-observability.png","description":"Tapping into the outputs available across API operations to understand what is happening with individual APIs throughout their lifecycle, but also in aggregate for domains, teams, and other logical groups, helping make API operations more visible in real time.","elements":[{"name":"Activity","label":"Activity"},{"name":"Reports","label":"Reports"},{"name":"Contract Testing Monitor Report","label":"Contract Testing Monitor Report"},{"name":"Application Performance Management (APM)","label":"Application Performance Management (APM)"}]}],
"discussion": "https://github.com/postman-open-technologies/lifecycle/discussions/33",
"yaml": "https://github.com/postman-open-technologies/lifecycle/blob/main/_blueprints/test-automation.md",
"roles": ["Advocate","Architect","Backend","DevOps","Engineering","Frontend","Mobile","Product","Support","Writers"],
"content": "&lt;p&gt;This blueprint focuses just on the test automation portion of the API lifecycle, highlighting the different types of tests that can be run, how monitors can be used to automate those tests on a schedule from multiple regions, and then how to tap into the observability opportunities that exist when it comes to test automation. Test automation should provide you with a 50K foot view of how testing works in conjunction with monitors, and what observability is available by default, published using visualizer, or introduced through integrations with external solutions, providing many different ways of being able to see and understand test automation for API operations.&lt;/p&gt;"
}
,

{
"name": "Testing",
"version": "2021-11-24",
"description": "",
"conclusion": "Text",
"image": "workflow.png",
"tags": ["Requests"],
"stage": "Automation",
"type": "sync",
"order": 1,
"status": "draft",
"maturity": "optimized",
"version": "2021-11-24",
"areas": [{"label":"Folders","description":"Text","image":"images/lifecycle-arrow-define.png","elements":[{"name":"Pre-Request Scripts","label":"Pre-Request Scripts"},{"name":"Test Scripts","label":"Test Scripts"}]},{"label":"Requests","description":"Text","image":"images/lifecycle-arrow-define.png","elements":[{"name":"Pre-Request Scripts","label":"Pre-Request Scripts"},{"name":"Test Scripts","label":"Test Scripts"}]},{"label":"Response","description":"Text","image":"images/lifecycle-arrow-define.png","elements":[{"name":"Test Results","label":"Test Results"}]},{"label":"Automation","description":"Text","image":"images/lifecycle-arrow-define.png","elements":[{"name":"Monitors","label":"Monitors"},{"name":"Pipelines","label":"Pipelines"}]},{"label":"Observability","description":"Text","image":"images/lifecycle-arrow-define.png","elements":[{"name":"Reporting","label":"Reporting"},{"name":"APM","label":"APM"}]}],
"discussion": "",
"yaml": "",
"roles": ["Backend","Data","DevOps","Engineering","Frontend","Mobile","Product","Security","Writers"],
"content": ""
}
,

{
"name": "The Base of the API Lifecycle",
"version": "2021-09-11",
"description": "",
"conclusion": "",
"image": "lifecycle.png",
"tags": ["Default"],
"stage": "Master",
"type": "sync",
"order": 1,
"status": "",
"maturity": "mature",
"version": "2021-09-11",
"areas": [{"label":"Define","description":"Making sure the operations around an API are properly defined, laying the foundation for being able to effectively design and bring an API to life, while also establishing a known place, or places to go to get all the information you need regarding each individual API or groups of APIs.","image":"images/lifecycle-arrow-define.png","elements":[{"name":"Team Members","label":"Team Members"},{"name":"Team Workspace","label":"Team Workspace"},{"name":"Public Workspace","label":"Public Workspace"},{"name":"Github Repository","label":"Github Repository"}]},{"label":"Design","image":"images/lifecycle-arrow-design.png","description":"Establishing a formal process and approach to designing an API helps establish consistency of each API that ends up in production, ensuring that APIs are developed using common industry and organizational patterns while establishing known practices for shaping the surface area and behaviors of APIs.","elements":[{"name":"OpenAPI","label":"OpenAPI"},{"name":"Mock Server","label":"Mock Server"},{"name":"Comments","label":"Comments"}]},{"label":"Document","image":"images/lifecycle-arrow-document.png","description":"Having complete, accurate, and easy to follow documentation is essential for all APIs, alleviating the number one pain point for API consumers when it comes to onboarding with APIs, providing the human-readable technical details of what an API does, helping minimize the time to first API call.","elements":[{"name":"Reference Documentation","label":"Reference Documentation","context":1},{"name":"Examples","label":"Examples","context":1}]},{"label":"Deploy","image":"images/lifecycle-arrow-deploy.png","description":"Providing a well-defined process to deploy an API into development, staging, and production environments, helping teams efficiently deliver future iterations of an API in a consistent and repeatable way, ensuring that APIs are properly tested, secured, and governed as a native part of the deployment process.","elements":[{"name":"CI/CD Pipeline","label":"CI/CD Pipeline","context":1},{"name":"Gateway","label":"Gateway","context":1},{"name":"Usage Plan","label":"Usage Plan","context":1}]},{"label":"Test","image":"images/lifecycle-arrow-test.png","description":"A test-driven API lifecycle ensures that each API delivers the intended outcomes it was developed for in the first place, providing manual as well as automated ways to ensure an API hasn't changed unexpectedly and is as performant as required, helping establish a high quality of service consistently across all APIs.","elements":[{"name":"Contract Testing","label":"Contract Testing","context":1},{"name":"Performance Testing","label":"Performance Testing","context":1}]},{"label":"Secure","image":"images/lifecycle-arrow-test.png","description":"Ensuring that there is a consistent approach to identity and access management for each API, but also the proper security testing in place to make sure that all APIs are being secured in a consistent way no matter which team developed them, or whether they will be used for private, partner, or public use in applications.","elements":[{"name":"Authentication","label":"Authentication","context":1},{"name":"Security Testing","label":"Security Testing","context":1}]},{"label":"Monitor","image":"images/lifecycle-arrow-monitor.png","description":"Making sure that all APIs are fully monitored by scheduling contract, performance, security, and other tests from multiple cloud regions, but also being able to monitor the activity, changelog, and state of an API using notifications, helping keep teams and consumers informed regarding the state of the APIs they depend on.","elements":[{"name":"Contract Testing Monitor","label":"Contract Testing Monitor","context":1},{"name":"Performance Testing Monitor","label":"Performance Testing Monitor","context":1},{"name":"Security Testing Monitor","label":"Security Testing Monitor","context":1},{"name":"Activity","label":"Activity"},{"name":"Change Log","label":"Change Log"},{"name":"Notifications","label":"Notifications"}]},{"label":"Discover","image":"images/lifecycle-arrow-discover.png","description":"Enabling discovery across operations, helping teams find existing APIs before they develop new ones, properly matching API consumers with the right APIs, while supporting documentation, workflows, and the feedback loops that exist as part of the operation of internal, partner, and public APIs supporting applications and integrations.","elements":[{"name":"Search","label":"Search","context":1},{"name":"Private Network","label":"Private Network","context":1},{"name":"Public Network","label":"Public Network","context":1}]}],
"discussion": "https://github.com/postman-open-technologies/lifecycle/discussions/27",
"yaml": "https://github.com/postman-open-technologies/lifecycle/blob/main/_blueprints/base.md",
"roles": ["Advocate","Architect","Backend","CIO","CISO","CTO","Data","DevOps","Engineering","Frontend","Mobile","Product","Sales","Security","Support","Writers"],
"content": "&lt;p&gt;The API lifecycle will mean many different things depending on who you are talking to. This base API lifecycle isn’t meant to be a lifecycle definition that matches the needs of every enterprise organization, but is intended to provide you with a base example to help you begin thinking about what your own API lifecycle is. The blueprint is designed to provide you a base that you can add to or remove from, iterating upon until you find a common definition of the API lifecycle that works for your organization.&lt;/p&gt;"
}
,

{
"name": "Visibility",
"version": "2021-11-24",
"description": "",
"conclusion": "Text",
"image": "workflow.png",
"tags": ["Requests"],
"stage": "Automation",
"type": "sync",
"order": 1,
"status": "draft",
"maturity": "optimized",
"version": "2021-11-24",
"areas": [{"label":"Private","description":"Text","image":"images/lifecycle-arrow-define.png","elements":[{"name":"Network","label":"Network"},{"name":"Workspaces","label":"Workspaces"},{"name":"Repositories","label":"Repositories"},{"name":"APIs","label":"APIs"},{"name":"Operations","label":"Operations"}]},{"label":"Partner","description":"Text","image":"images/lifecycle-arrow-define.png","elements":[{"name":"Network","label":"Network"},{"name":"Workspaces","label":"Workspaces"},{"name":"Repositories","label":"Repositories"},{"name":"APIs","label":"APIs"},{"name":"Operations","label":"Operations"}]},{"label":"Public","description":"Text","image":"images/lifecycle-arrow-define.png","elements":[{"name":"Network","label":"Network"},{"name":"Workspaces","label":"Workspaces"},{"name":"Repositories","label":"Repositories"},{"name":"APIs","label":"APIs"},{"name":"Operations","label":"Operations"}]}],
"discussion": "",
"yaml": "",
"roles": ["Advocate"],
"content": ""
}
,

{
"name": "Workflow Collection",
"version": "2021-11-24",
"description": "",
"conclusion": "Text",
"image": "workflow.png",
"tags": ["Requests"],
"stage": "Automation",
"type": "sync",
"order": 1,
"status": "draft",
"maturity": "optimized",
"version": "2021-11-24",
"areas": [{"label":"Purpose","description":"Text","image":"images/lifecycle-arrow-define.png","elements":[{"name":"Business Process","label":"Business Process"},{"name":"Documentation","label":"Documentation"},{"name":"Multiple APIs","label":"Multiple APIs"},{"name":"Orchestration","label":"Orchestration"},{"name":"Engagement","label":"Engagement"}]},{"label":"Structure","description":"Text","image":"images/lifecycle-arrow-define.png","elements":[{"name":"Authorization","label":"Authorization"},{"name":"Folders","label":"Folders"},{"name":"Requests","label":"Requests"},{"name":"Scripts","label":"Scripts"},{"name":"Examples","label":"Examples"}]},{"label":"Environment","description":"Text","image":"images/lifecycle-arrow-define.png","elements":[{"name":"Stages","label":"Stages"},{"name":"Variables","label":"Variables"},{"name":"Authorization Variables","label":"Authorization Variables"}]},{"label":"Engagement","description":"Text","image":"images/lifecycle-arrow-define.png","elements":[{"name":"Collection URL","label":"Collection URL"},{"name":"Collection Button","label":"Collection Button"},{"name":"Collection Watch","label":"Collection Watch"},{"name":"Collection Fork","label":"Collection Fork"},{"name":"Collection Pull Request","label":"Collection Pull Request"},{"name":"Collection Merge","label":"Collection Merge"}]}],
"discussion": "",
"yaml": "",
"roles": ["Advocate","Architect","CIO","CISO","CTO","Engineering","Product"],
"content": ""
}
,

{
"name": "Workspaces",
"version": "2021-11-24",
"description": "",
"conclusion": "Text",
"image": "workflow.png",
"tags": ["Requests"],
"stage": "Automation",
"type": "sync",
"order": 1,
"status": "draft",
"maturity": "optimized",
"version": "2021-11-24",
"areas": [{"label":"Contents","description":"Text","image":"images/lifecycle-arrow-define.png","elements":[{"name":"Collections","label":"Collections"},{"name":"APIs","label":"APIs"},{"name":"Environments","label":"Environments"},{"name":"Monitors","label":"Monitors"}]},{"label":"Visibility","description":"Text","image":"images/lifecycle-arrow-define.png","elements":[{"name":"Private","label":"Private"},{"name":"Partner","label":"Partner"},{"name":"Public","label":"Public"}]},{"label":"Engagement","description":"Text","image":"images/lifecycle-arrow-define.png","elements":[{"name":"Contributors","label":"Contributors"},{"name":"Team","label":"Team"},{"name":"Watches","label":"Watches"},{"name":"Activity","label":"Activity"}]}],
"discussion": "",
"yaml": "",
"roles": ["Advocate","Architect","CIO","CISO","CTO","Engineering","Product"],
"content": ""
}


]